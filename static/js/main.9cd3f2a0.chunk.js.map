{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/astar.js","algorithms/dijkstras.js","PathfindingVisualizer/PathfindingVisualizer3.jsx","App.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isVisited","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","id","className","React","Component","ManhattanDistance","currentNode","targetNode","Math","abs","sortNodesByFScore","grid","sort","nodeA","nodeB","fscore","getUnvisitedNeighbours","node","neighbours","push","length","filter","neighbour","updateUnvisitedNeighbours","distance","previousNode","dijkstra","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","pop","PathfindingVisualizer3","getInitialGrid","navbarHeight","document","getElementById","clientHeight","numCols","floor","window","innerWidth","numRows","innerHeight","setState","console","log","currentRow","createNode","algorithm","mouseIsPressed","startNodePressed","finishNodePressed","start","finish","speedText","speedSeconds","prevNode","visited","counted","animateAlgorithm","bind","handleMouseDown","handleMouseUp","handleMouseEnter","setSpeed","setAlgorithm","gscore","hscore","newGrid","slice","newNode","type","getNewGridWithNodeToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","singleAnimationDuration","i","setTimeout","animateShortestPath","closedList","openList","includes","astar","unshift","getNodesInShortestPathOrder","random","randomRow","randomCol","event","target","name","value","root","clientWidth","onChange","onClick","visualize","generateRandomMaze","reset","map","rowIdx","key","nodeIdx","App","ReactDOM","render"],"mappings":"iWAeqBA,G,wDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,qDAIT,IAAD,EAWHC,KAAKF,MATPG,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,QACAC,EALK,EAKLA,SACAC,EANK,EAMLA,UACAC,EAPK,EAOLA,OACAC,EARK,EAQLA,UACAC,EATK,EASLA,YACAC,EAVK,EAULA,aAIIC,EAAiBN,EACnB,cACAD,EACA,aACAG,EACA,YACAD,EACA,eACA,GACJ,OACE,yBACEM,GAAE,eAAUV,EAAV,YAAiBC,GACnBU,UAAS,eAAUF,GACnBF,YAAa,kBAAMA,EAAYP,EAAKC,IACpCO,aAAc,kBAAMA,EAAaR,EAAKC,IACtCK,UAAW,kBAAMA,EAAUN,EAAKC,U,GAlCNW,IAAMC,Y,eCuCxC,SAASC,EAAkBC,EAAaC,GAItC,OAFEC,KAAKC,IAAIH,EAAYd,IAAMe,EAAWf,KACtCgB,KAAKC,IAAIH,EAAYf,IAAMgB,EAAWhB,KAQ1C,SAASmB,EAAkBC,GACzBA,EAAKC,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAME,OAASD,EAAMC,UAkBnD,SAASC,EAAuBC,EAAMN,GACpC,IAAMO,EAAa,GACX1B,EAAayB,EAAbzB,IAAKD,EAAQ0B,EAAR1B,IAiBb,OAfIA,EAAM,GACR2B,EAAWC,KAAKR,EAAKpB,EAAM,GAAGC,IAG5BD,EAAMoB,EAAKS,OAAS,GACtBF,EAAWC,KAAKR,EAAKpB,EAAM,GAAGC,IAG5BA,EAAM,GACR0B,EAAWC,KAAKR,EAAKpB,GAAKC,EAAM,IAG9BA,EAAMmB,EAAKpB,GAAK6B,OAAS,GAC3BF,EAAWC,KAAKR,EAAKpB,GAAKC,EAAM,IAE3B0B,EAAWG,QAAO,SAACC,GAAD,OAAgBA,EAAU3B,aAQrD,SAAS4B,EAA0BN,EAAMN,GACvC,IAD6C,EACvCO,EAAaF,EAAuBC,EAAMN,GADH,cAErBO,GAFqB,IAE7C,2BAAoC,CAAC,IAA1BI,EAAyB,QAClCA,EAAUE,SAAWP,EAAKO,SAAW,EACrCF,EAAUG,aAAeR,GAJkB,+BCxGxC,SAASS,EAASf,EAAMgB,EAAWC,GAOxC,IAAMC,EAAsB,GAC5BF,EAAUH,SAAW,EAIrB,IAHA,IAAMM,EAiCR,SAAqBnB,GACnB,IADyB,EACnBoB,EAAQ,GADW,cAEPpB,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbpB,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAd0B,EAAa,QACtBc,EAAMZ,KAAKF,IAFS,gCAFC,8BAOzB,OAAOc,EAxCgBC,CAAYrB,GAG1BmB,EAAeV,QAAQ,CAC9Ba,EAAoBH,GACpB,IAAMI,EAAcJ,EAAeK,QAGnC,IAAID,EAAYtC,OAAhB,CAKA,GAAIsC,EAAYV,WAAaY,IAE3B,OADAP,EAAoBQ,MACbR,EAOT,GAJAK,EAAYvC,WAAY,EACxBkC,EAAoBV,KAAKe,GAGrBA,IAAgBN,EAClB,OAAOC,EAETN,EAA0BW,EAAavB,KAmD3C,SAASY,EAA0BN,EAAMN,GACvC,IAD6C,EACvCO,EA5BR,SAAgCD,EAAMN,GACpC,IAAMO,EAAa,GACX1B,EAAayB,EAAbzB,IAAKD,EAAQ0B,EAAR1B,IAiBb,OAfIA,EAAM,GACR2B,EAAWC,KAAKR,EAAKpB,EAAM,GAAGC,IAG5BD,EAAMoB,EAAKS,OAAS,GACtBF,EAAWC,KAAKR,EAAKpB,EAAM,GAAGC,IAG5BA,EAAM,GACR0B,EAAWC,KAAKR,EAAKpB,GAAKC,EAAM,IAG9BA,EAAMmB,EAAKpB,GAAK6B,OAAS,GAC3BF,EAAWC,KAAKR,EAAKpB,GAAKC,EAAM,IAE3B0B,EAAWG,QAAO,SAACC,GAAD,OAAgBA,EAAU3B,aAShCqB,CAAuBC,EAAMN,GADH,cAErBO,GAFqB,IAE7C,2BAAoC,CAAC,IAA1BI,EAAyB,QAClCA,EAAUE,SAAWP,EAAKO,SAAW,EACrCF,EAAUG,aAAeR,GAJkB,+BAY/C,SAASgB,EAAoBH,GAC3BA,EAAelB,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMW,SAAWV,EAAMU,Y,IChG1Cc,E,kDACnB,WAAYlD,GAAQ,IAAD,8BACjB,cAAMA,IAkCRmD,eAAiB,WACf,IAAIC,EAAeC,SAASC,eAAe,UAAUC,aAC/ChC,EAAO,GACPiC,EAAUpC,KAAKqC,OAAOC,OAAOC,WAAa,KAAO,IACjDC,EAAUxC,KAAKqC,OAAOC,OAAOG,YAAcT,EAAe,KAAO,IACvE,EAAKU,SAAS,CAACF,UAASJ,YACxBO,QAAQC,IAAR,mBAAwBR,EAAxB,qBAA4CI,IAC5C,IAAK,IAAIzD,EAAM,EAAGA,EAAMyD,EAASzD,IAAO,CAEtC,IADA,IAAM8D,EAAa,GACV7D,EAAM,EAAGA,EAAMoD,EAASpD,IAC/B6D,EAAWlC,KAAK,EAAKmC,WAAW9D,EAAKD,IAEvCoB,EAAKQ,KAAKkC,GAEZ,OAAO1C,GA/CP,EAAKtB,MAAQ,CACXsB,KAAM,GACNqC,QAAS,EACTJ,QAAS,EACTW,UAAW,aACXC,gBAAgB,EAChBC,kBAAkB,EAClBC,mBAAmB,EACnBC,MAAO,CAAEnE,IAAK,EAAGD,IAAK,IACtBqE,OAAQ,CAAEpE,IAAK,GAAID,IAAK,IACxBsE,UAAW,OACXC,aAAc,GACdC,SAAU,KACVC,QAAS,EACTC,QAAS,GAEX,EAAKC,iBAAmB,EAAKA,iBAAiBC,KAAtB,gBACxB,EAAKC,gBAAkB,EAAKA,gBAAgBD,KAArB,gBACvB,EAAKE,cAAgB,EAAKA,cAAcF,KAAnB,gBACrB,EAAKG,iBAAmB,EAAKA,iBAAiBH,KAAtB,gBACxB,EAAKI,SAAW,EAAKA,SAASJ,KAAd,gBAChB,EAAKK,aAAe,EAAKA,aAAaL,KAAlB,gBAvBH,E,gEA2BjB,IAAMxD,EAAOrB,KAAKiD,iBAClBjD,KAAK4D,SAAS,CAAEvC,KAAMA,M,iCA8BbnB,EAAKD,GACd,MAAO,CACLC,MACAD,MACAE,QAASF,IAAQD,KAAKD,MAAMsE,MAAMpE,KAAOC,IAAQF,KAAKD,MAAMsE,MAAMnE,IAClEE,SAAUH,IAAQD,KAAKD,MAAMuE,OAAOrE,KAAOC,IAAQF,KAAKD,MAAMuE,OAAOpE,IACrEgC,SAAUY,IACVzC,WAAW,EACXC,QAAQ,EACR6B,aAAc,KACdgD,OAAQ,EACRC,OAAQ,EACR3D,OAAQ,K,gDAWcJ,EAAMpB,EAAKC,GAEnC,IAAMmF,EAAUhE,EAAKiE,QAGf3D,EAAO0D,EAAQpF,GAAKC,GAGpBqF,EAAO,2BACR5D,GADQ,IAEXrB,QAASqB,EAAKrB,SAKhB,OADA+E,EAAQpF,GAAKC,GAAOqF,EACbF,I,gDAWiBG,EAAMnE,EAAMpB,EAAKC,GACzC,IAAMmF,EAAUhE,EAAKiE,QACf3D,EAAO0D,EAAQpF,GAAKC,GACpBqF,EAAO,2BACR5D,GADQ,IAEXxB,QAAkB,UAATqF,GAAoB7D,EAAKxB,QAAUwB,EAAKxB,QACjDC,SAAmB,WAAToF,GAAqB7D,EAAKvB,SAAWuB,EAAKvB,WAGtD,OADAiF,EAAQpF,GAAKC,GAAOqF,EACbF,I,sCAQOpF,EAAKC,GACnB,GAAID,IAAQD,KAAKD,MAAMsE,MAAMpE,KAAOC,IAAQF,KAAKD,MAAMsE,MAAMnE,IAAK,CAChE2D,QAAQC,IAAR,yBAA8B7D,EAA9B,iBAA0CC,IAG1C,IAAMmF,EAAUrF,KAAKyF,0BACnB,QACAzF,KAAKD,MAAMsB,KACXpB,EACAC,GAEFF,KAAK4D,SAAS,CACZvC,KAAMgE,EACNnB,gBAAgB,EAChBC,kBAAkB,SAEf,GAAIlE,IAAQD,KAAKD,MAAMuE,OAAOrE,KAAOC,IAAQF,KAAKD,MAAMuE,OAAOpE,IAAK,CACzE2D,QAAQC,IAAR,yBAA8B7D,EAA9B,iBAA0CC,IAG1C,IAAMmF,EAAUrF,KAAKyF,0BACnB,SACAzF,KAAKD,MAAMsB,KACXpB,EACAC,GAEFF,KAAK4D,SAAS,CACZvC,KAAMgE,EACNnB,gBAAgB,EAChBE,mBAAmB,QAEhB,CAEL,IAAMiB,EAAUrF,KAAK0F,0BAA0B1F,KAAKD,MAAMsB,KAAMpB,EAAKC,GACrEF,KAAK4D,SAAS,CAAEvC,KAAMgE,EAASnB,gBAAgB,O,oCASrCjE,EAAKC,GAEjB,GAAIF,KAAKD,MAAMoE,iBAAkB,CAC/BN,QAAQC,IAAR,uBAA4B7D,EAA5B,iBAAwCC,IACxC,IAAMmF,EAAUrF,KAAKyF,0BACnB,QACAzF,KAAKD,MAAMsB,KACXpB,EACAC,GAEFF,KAAK4D,SAAS,CACZvC,KAAMgE,EACNhB,MAAO,CAAEpE,IAAKA,EAAKC,IAAKA,GACxBiE,kBAAkB,EAClBD,gBAAgB,SAEb,GAAIlE,KAAKD,MAAMqE,kBAAmB,CACvC,IAAMiB,EAAUrF,KAAKyF,0BACnB,SACAzF,KAAKD,MAAMsB,KACXpB,EACAC,GAEFF,KAAK4D,SAAS,CACZvC,KAAMgE,EACNf,OAAQ,CAAErE,IAAKA,EAAKC,IAAKA,GACzBkE,mBAAmB,EACnBF,gBAAgB,SAGlBlE,KAAK4D,SAAS,CAAEM,gBAAgB,M,uCASnBjE,EAAKC,GACpB,GAAKF,KAAKD,MAAMmE,eAAhB,CACA,GACElE,KAAKD,MAAMmE,iBACVlE,KAAKD,MAAMoE,mBACXnE,KAAKD,MAAMqE,kBACZ,CAEA,IAAMiB,EAAUrF,KAAK0F,0BAA0B1F,KAAKD,MAAMsB,KAAMpB,EAAKC,GACrEF,KAAK4D,SAAS,CAAEvC,KAAMgE,IAEpBrF,KAAKD,MAAMoE,mBACbN,QAAQC,IAAR,0BAA+B7D,EAA/B,iBAA2CC,IAC3CF,KAAK4D,SAAS,CACZS,MAAO,CAAEpE,IAAKA,EAAKC,IAAKA,MAGxBF,KAAKD,MAAMqE,mBACbpE,KAAK4D,SAAS,CACZU,OAAQ,CAAErE,IAAKA,EAAKC,IAAKA,Q,uCAWdqC,EAAqBoD,GAIpC,IAJ+D,IAAD,OACxDC,EAA0B5F,KAAKD,MAAMyE,aADmB,WAIrDqB,GAEP,GAAIA,IAAMtD,EAAoBT,OAI5B,OAHAgE,YAAW,WACT,EAAKC,oBAAoBJ,KACxBC,EAA0BC,GACvB,CAAN,UAIFC,YAAW,WACT,IAAMnE,EAAOY,EAAoBsD,GACjC1C,SAASC,eAAT,eAAgCzB,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOU,UACtD,sBACDgF,EAA0BC,GAG7B,EAAKjC,SAAS,CAAEc,QAASmB,EAAI,KAjBtBA,EAAI,EAAGA,GAAKtD,EAAoBT,OAAQ+D,IAAK,CAAC,IAAD,IAA7CA,GAA6C,qC,0CAyBpCF,GAA2B,IAAD,OACtCC,EAA0B5F,KAAKD,MAAMyE,aAI3C,GAAImB,EAAyB7D,OAAS,EAEpC,IAFwC,IAAD,WAE9B+D,GACPC,YAAW,WACT,IAAMnE,EAAOgE,EAAyBE,GACtC1C,SAASC,eAAT,eAAgCzB,EAAK1B,IAArC,YAA4C0B,EAAKzB,MAAOU,UACtD,4BACDgF,EAA0BC,GAG7B,EAAKjC,SAAS,CAAEe,QAASkB,EAAI,KARtBA,EAAI,EAAGA,EAAIF,EAAyB7D,OAAQ+D,IAAM,EAAlDA,K,kCAgBA,IACHxE,EAASrB,KAAKD,MAAdsB,KACFgB,EAAYhB,EAAKrB,KAAKD,MAAMsE,MAAMpE,KAAKD,KAAKD,MAAMsE,MAAMnE,KACxDoC,EAAajB,EAAKrB,KAAKD,MAAMuE,OAAOrE,KAAKD,KAAKD,MAAMuE,OAAOpE,KAM7DqC,EAAsB,GAC1B,OAAQvC,KAAKD,MAAMkE,WACjB,IAAK,aACH1B,EAAsBH,EAASf,EAAMgB,EAAWC,GAChD,MACF,IAAK,KACHC,EFlTD,SAAelB,EAAMgB,EAAWC,GACrC,IAAM0D,EAAa,GACbC,EAAW,CAAC5D,GAKlB,IAHAA,EAAU8C,OAAS,EACnB9C,EAAUZ,OAASV,EAAkBsB,EAAWC,GAEvC2D,EAASnE,QAAQ,CACxBV,EAAkB6E,GAClB,IAAMjF,EAAciF,EAASpD,QAG7B,GAFAgB,QAAQC,IAAR,uBAA4B9C,EAAYd,IAAxC,YAA+Cc,EAAYf,OAEvDe,EAAYV,OAAhB,CAIA,GAAIU,IAAgBsB,EAElB,OADAuB,QAAQC,IAAI,eAAgBkC,GACrBA,EAGThF,EAAYX,WAAY,EACxB2F,EAAWnE,KAAKb,GAEhB,IAjBwB,EAiBlBY,EAAaF,EAAuBV,EAAaK,GAjB/B,cAkBAO,GAlBA,IAkBxB,2BAAoC,CAAC,IAA1BI,EAAyB,QAC7BgE,EAAWE,SAASlE,KACvBA,EAAUmD,OAASnE,EAAYmE,OAAS,EACxCnD,EAAUoD,OAASrE,EAAkBiB,EAAWM,GAChDN,EAAUP,OAASO,EAAUmD,OAASnD,EAAUoD,OAE3Ca,EAASC,SAASlE,IACrBiE,EAASpE,KAAKG,KAzBI,8BA8BxBC,EAA0BjB,EAAaK,KE6Qb8E,CAAM9E,EAAMgB,EAAWC,GAOjD,IAAMqD,ED7MH,SAAqCrD,GAG1C,IAFA,IAAMqD,EAA2B,GAC7B3E,EAAcsB,EACK,OAAhBtB,GACL2E,EAAyBS,QAAQpF,GACjCA,EAAcA,EAAYmB,aAE5B,OAAOwD,ECsM4BU,CAA4B/D,GAG7DtC,KAAK4E,iBAAiBrC,EAAqBoD,K,2CAU3C,IAJmB,MAEQ3F,KAAKD,MAAzB2D,EAFY,EAEZA,QAASJ,EAFG,EAEHA,QACZ+B,EAAU,GACLQ,EAAI,EAAGA,EAAI3E,KAAKqC,MAAMrC,KAAKoF,SAAWhD,EAAUI,GAAUmC,IAAK,CACtE,IAAMU,EAAYrF,KAAKqC,MAAMrC,KAAKoF,SAAW5C,GACvC8C,EAAYtF,KAAKqC,MAAMrC,KAAKoF,SAAWhD,GAE1CiD,IAAcvG,KAAKD,MAAMsE,MAAMpE,KAC9BuG,IAAcxG,KAAKD,MAAMsE,MAAMnE,KAChCqG,IAAcvG,KAAKD,MAAMuE,OAAOrE,KAC/BuG,IAAcxG,KAAKD,MAAMuE,OAAOpE,MAGlCmF,EAAUrF,KAAK0F,0BACb1F,KAAKD,MAAMsB,KACXkF,EACAC,GAEFxG,KAAK4D,SAAS,CAAEvC,KAAMgE,Q,mCASfoB,GAAQ,IAAD,EACMA,EAAMC,OAAtBC,EADU,EACVA,KAAMC,EADI,EACJA,MACd5G,KAAK4D,SAAL,eAAiB+C,EAAOC,M,+BAOjBH,GAAQ,IAAD,QACUA,EAAMC,OAAtBC,EADM,EACNA,KAAMC,EADA,EACAA,MACJ,SAAVA,EACI5G,KAAK4D,UAAL,mBAAiB+C,EAAOC,GAAxB,6BAA6C,IAA7C,IACU,YAAVA,EACA5G,KAAK4D,UAAL,mBAAiB+C,EAAOC,GAAxB,6BAA6C,IAA7C,IACA5G,KAAK4D,UAAL,mBAAiB+C,EAAOC,GAAxB,6BAA6C,KAA7C,M,kCAOJ/C,QAAQC,IAAR,wBACmBN,OAAOC,WAD1B,gCAC4DD,OAAOG,cAEnE,IAAIkD,EAAO1D,SAASC,eAAe,QACnCS,QAAQC,IAAR,4BACuB+C,EAAKC,YAD5B,+BAC8DD,EAAKxD,iB,8BASnE,IAFM,IAAD,EAC4BrD,KAAKD,MAA/BsB,EADF,EACEA,KAAMqC,EADR,EACQA,QAASJ,EADjB,EACiBA,QACbrD,EAAM,EAAGA,EAAMyD,EAASzD,IAC/B,IAAK,IAAIC,EAAM,EAAGA,EAAMoD,EAASpD,IAC3BmB,EAAKpB,GAAKC,GAAKC,QACjBgD,SAASC,eAAT,eAAgCnD,EAAhC,YAAuCC,IAAOU,UAAY,kBACjDS,EAAKpB,GAAKC,GAAKE,SACxB+C,SAASC,eAAT,eAAgCnD,EAAhC,YAAuCC,IAAOU,UAAY,oBAEvDS,EAAKpB,GAAKC,GAAKI,SAAQe,EAAKpB,GAAKC,GAAKI,QAAS,GAClD6C,SAASC,eAAT,eAAgCnD,EAAhC,YAAuCC,IAAOU,UAAY,QAIhEZ,KAAK4D,SAAS,CAACvC,OAAMqD,QAAS,EAAGC,QAAS,M,+BAWlC,IAAD,SAC4B3E,KAAKD,MAAhCsB,EADD,EACCA,KAAMqD,EADP,EACOA,QAASC,EADhB,EACgBA,QAEvB,OACE,6BACE,yBAAKhE,GAAG,UACN,sDACA,yBAAKA,GAAG,YACN,8CAAoB+D,GACpB,8CAAoBC,IAEtB,6BACE,4BACEhE,GAAG,gBACHgG,KAAK,YACLC,MAAO5G,KAAKD,MAAMkE,UAClB8C,SAAU/G,KAAKkF,cAEf,4BAAQ0B,MAAM,cAAd,eACA,4BAAQA,MAAM,MAAd,OAEF,4BAAQjG,GAAG,MAAMqG,QAAS,kBAAM,EAAKC,cAArC,aACajH,KAAKD,MAAMkE,WAExB,4BAAQtD,GAAG,MAAMqG,QAAS,kBAAM,EAAKE,uBAArC,yBAGA,4BAAQvG,GAAG,MAAMqG,QAAS,kBAAM,EAAKG,UAArC,SAGA,4BACExG,GAAG,iBACHgG,KAAK,YACLC,MAAO5G,KAAKD,MAAMwE,UAClBwC,SAAU/G,KAAKiF,UAEf,4BAAQ2B,MAAM,QAAd,QACA,4BAAQA,MAAM,WAAd,WACA,4BAAQA,MAAM,QAAd,WAKN,yBAAKhG,UAAU,QACZS,EAAK+F,KAAI,SAACnH,EAAKoH,GACd,OACE,yBAAKC,IAAKD,GACPpH,EAAImH,KAAI,SAACzF,EAAM4F,GAAa,IAEzBtH,EAME0B,EANF1B,IACAC,EAKEyB,EALFzB,IACAC,EAIEwB,EAJFxB,QACAC,EAGEuB,EAHFvB,SAEAE,EACEqB,EADFrB,OAEF,OACE,kBAAC,EAAD,CACEgH,IAAKC,EACLtH,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EAEVE,OAAQA,EACRE,YAAa,SAACP,EAAKC,GAAN,OAAc,EAAK4E,gBAAgB7E,EAAKC,IACrDO,aAAc,SAACR,EAAKC,GAAN,OACZ,EAAK8E,iBAAiB/E,EAAKC,IAE7BK,UAAW,SAACN,EAAKC,GAAN,OAAc,EAAK6E,cAAc9E,EAAKC,mB,GA5dnBW,IAAMC,WCK3C0G,MARf,WACE,OACE,yBAAK5G,UAAU,OACb,kBAAC,EAAD,QCJN6G,IAASC,OACP,kBAAC,EAAD,MACAvE,SAASC,eAAe,W","file":"static/js/main.9cd3f2a0.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\n/** \r\n * @class Represents a node in the grid which can be the \r\n * starting node, the ending node or a wall.\r\n * @prop {Number} row The row of the Node\r\n * @prop {number} col The col of the Node\r\n * @prop {boolean} isStart Is the Node a starting node\r\n * @prop {boolean} isFinish Is the Node an ending node\r\n * @prop {boolean} isVisited Has the Node been visited\r\n * @prop {function} onMouseUp Function to execute when mouse is up (released)\r\n * @prop {function} onMouseDown Function to execute when mouse is down (clicked)\r\n * @prop {function} onMouseEnter Function to execute when mouse enters the Node\r\n */\r\nexport default class Node extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseUp,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n    } = this.props;\r\n\r\n    // Add extra class name for start, finish, wall or visited node\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","/**\r\n * @description Finds the shortest path between startNode and finishNode using the A* search algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes in the shortest path\r\n */\r\nexport function astar(grid, startNode, finishNode) {\r\n  const closedList = [];\r\n  const openList = [startNode]; //getAllNodes(grid);\r\n  //openList.unshift(startNode);\r\n  startNode.gscore = 0;\r\n  startNode.fscore = ManhattanDistance(startNode, finishNode);\r\n\r\n  while (!!openList.length) {\r\n    sortNodesByFScore(openList);\r\n    const currentNode = openList.shift();\r\n    console.log(`currentNode: ${currentNode.col} ${currentNode.row}`);\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    //if (currentNode.distance === Infinity) return false;\r\n\r\n    if (currentNode === finishNode) {\r\n      console.log(\"closedList: \", closedList);\r\n      return closedList;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    closedList.push(currentNode);\r\n\r\n    const neighbours = getUnvisitedNeighbours(currentNode, grid);\r\n    for (const neighbour of neighbours) {\r\n      if (!closedList.includes(neighbour)) {\r\n        neighbour.gscore = currentNode.gscore + 1; //1 is the distance between currentNode and neighbour\r\n        neighbour.hscore = ManhattanDistance(neighbour, finishNode);\r\n        neighbour.fscore = neighbour.gscore + neighbour.hscore;\r\n\r\n        if (!openList.includes(neighbour)) {\r\n          openList.push(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    updateUnvisitedNeighbours(currentNode, grid);\r\n  }\r\n}\r\n\r\n/**\r\n * @description Manhattan distance between (x1,y1) and (x2,y2) is calculated as |x1-x2| + |y1-y2|\r\n * @param {Node} currentNode\r\n * @param {Node} targetNode\r\n * @returns Manhattan distance between currentNode and targetNode\r\n */\r\nfunction ManhattanDistance(currentNode, targetNode) {\r\n  const temp =\r\n    Math.abs(currentNode.col - targetNode.col) +\r\n    Math.abs(currentNode.row - targetNode.row);\r\n  return temp;\r\n}\r\n\r\n/**\r\n * @description Sorts the entire grid by the f-score\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nfunction sortNodesByFScore(grid) {\r\n  grid.sort((nodeA, nodeB) => nodeA.fscore - nodeB.fscore);\r\n}\r\n\r\n// function getAllNodes(grid) {\r\n//   const nodes = [];\r\n//   for (const row of grid) {\r\n//     for (const node of row) {\r\n//       nodes.push(node);\r\n//     }\r\n//   }\r\n//   return nodes;\r\n// }\r\n\r\n/**\r\n * @param {Node} node Node whose neighbours are fetched\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @returns {Node[]} Unvisited neighbours of Node node as a 1D array\r\n */\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\n/**\r\n * @description Sets the visited state of the neighbours of Node node to true.\r\n * @param {Node} node Node whose neighbours have to be updated\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * @description Gets the Nodes in the shortest path from start to target\r\n * @param {Node} finishNode The target Node\r\n * @returns {Node[]} Array containing Nodes in shortest path\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","/**\r\n * @description Finds the shortest path between startNode and finishNode using Dijkstra's shortest path algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes in the shortest path\r\n */\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  /*\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    //Exceptional case with no startNode, no finishNode, or when they're equal\r\n    return false;\r\n  } */\r\n\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  // While there are still nodes to visit\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift(); //removes closestNode from unvisitedNodes\r\n\r\n    // If the closest node is a wall\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n\r\n    //When there are NO valid paths. Eg. walls around source or target\r\n    if (closestNode.distance === Infinity) {\r\n      visitedNodesInOrder.pop();\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // Found target\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(closestNode, grid);\r\n  }\r\n}\r\n\r\n/**\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @returns {Node[]} 1D rray containing all nodes in grid\r\n */\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * @description Gets the unvisited neighbours of Node node\r\n * @param {Node} node Node whose neighbours are fetched\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @returns\r\n */\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\n/**\r\n * @description Sets the visited state of the neighbours of Node node to true.\r\n * @param {Node} node Node whose neighbours have to be updated\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * @description Sorts Nodes by distance\r\n * @param {Node[]} unvisitedNodes Array of unvisited Nodes\r\n */\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); //Absolute value?\r\n}\r\n\r\n/**\r\n * @description Gets the Nodes in the shortest path from start to finish.\r\n * Backtracks from the finishNode to find the shortest path.\r\n * Only works when called *after* the dijkstra method above.\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes in the shortest path as an array\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { astar } from \"../algorithms/astar\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/dijkstras.js\";\r\n\r\nexport default class PathfindingVisualizer3 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      numRows: 0,\r\n      numCols: 0,\r\n      algorithm: \"Dijkstra's\",\r\n      mouseIsPressed: false,\r\n      startNodePressed: false,\r\n      finishNodePressed: false,\r\n      start: { col: 5, row: 10 },\r\n      finish: { col: 20, row: 10 },\r\n      speedText: \"Fast\",\r\n      speedSeconds: 10,\r\n      prevNode: null,\r\n      visited: 0,\r\n      counted: 0,\r\n    };\r\n    this.animateAlgorithm = this.animateAlgorithm.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.setSpeed = this.setSpeed.bind(this);\r\n    this.setAlgorithm = this.setAlgorithm.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  /**\r\n   * @description Creates a grid of Nodes\r\n   * @returns Grid (2D array) of Nodes\r\n   */\r\n  getInitialGrid = () => {\r\n    var navbarHeight = document.getElementById(\"navbar\").clientHeight;\r\n    const grid = [];\r\n    const numCols = Math.floor((window.innerWidth - 160) / 40);\r\n    const numRows = Math.floor((window.innerHeight - navbarHeight - 120) / 40);\r\n    this.setState({numRows, numCols})\r\n    console.log(`numCols: ${numCols} numRows: ${numRows}`);\r\n    for (let row = 0; row < numRows; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < numCols; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  /**\r\n   * @description Creates a single unvisited Node that is not a wall\r\n   * @param {number} col The column of the Node to be created\r\n   * @param {number} row The row of the Node to be created\r\n   * @returns \r\n   */\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start.row && col === this.state.start.col,\r\n      isFinish: row === this.state.finish.row && col === this.state.finish.col,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      gscore: 0,\r\n      hscore: 0,\r\n      fscore: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @description Toggles the wall state of Node at (row, col) \r\n   * @param {Node[][]} grid Grid (2D array) of Nodes\r\n   * @param {number} row Row of the Node to toggle to wall\r\n   * @param {number} col Column of the Node to toggle to wall\r\n   * @returns Grid with wall toggled at (row, col)\r\n   */\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    // (Shallow) Copy the entire grid\r\n    const newGrid = grid.slice();\r\n\r\n    // Get the reference to the Node to change to wall\r\n    const node = newGrid[row][col];\r\n\r\n    // Make new Node with toggled wall\r\n    const newNode = {\r\n      ...node, // Get other details using the spread operator\r\n      isWall: !node.isWall,\r\n    };\r\n\r\n    // Set newNode in the new grid\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  /**\r\n   * @description Toggles Node at (row, col) to a start/finish Node\r\n   * @param {string} type Type of Node to toggle to, ie. start or finish Node\r\n   * @param {Node[][]} grid Grid (2D array) of Nodes\r\n   * @param {number} row Row of the Node to toggle start/finish node\r\n   * @param {number} col Column of the Node to toggle to start/finish node\r\n   * @returns Grid with Node toggled at (row, col) to start/finish Node\r\n   */\r\n  getNewGridWithNodeToggled(type, grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: type === \"start\" ? !node.isStart : node.isStart,\r\n      isFinish: type === \"finish\" ? !node.isFinish : node.isFinish,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  /**\r\n   * @description Handles the necessary state changes when a Node is clicked but not released\r\n   * @param {number} row Row of the Node which has been clicked \r\n   * @param {number} col Column of the Node which has been clicked \r\n   */\r\n  handleMouseDown(row, col) {\r\n    if (row === this.state.start.row && col === this.state.start.col) { // Start Node is pressed\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      // Toggle start Node to unvisited Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        startNodePressed: true,\r\n      });\r\n    } else if (row === this.state.finish.row && col === this.state.finish.col) { // Finish Node is pressed\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      // Toggle finish Node to unvisited Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        finishNodePressed: true,\r\n      });\r\n    } else { //Unvisited Node is pressed\r\n      // Toggle unvisited Node to wall Node\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Handles the necessary state changes when a Node is released\r\n   * @param {number} row Row of the Node which has been released \r\n   * @param {number} col Column of the Node which has been released \r\n   */\r\n  handleMouseUp(row, col) {\r\n    //Originally there was no row, col being passed\r\n    if (this.state.startNodePressed) { //Start Node\r\n      console.log(`mouse UP row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        start: { row: row, col: col },\r\n        startNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else if (this.state.finishNodePressed) { // Finish Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        finish: { row: row, col: col },\r\n        finishNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else { // Unvisited Node\r\n      this.setState({ mouseIsPressed: false });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Toggles Node at (row, col) to start, finish or wall Node\r\n   * @param {number} row Row of the Node that the mouse enters \r\n   * @param {number} col Column of the Node that the mouse enters\r\n   */\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (\r\n      this.state.mouseIsPressed &&\r\n      !this.state.startNodePressed &&\r\n      !this.state.finishNodePressed\r\n    ) {\r\n      // Toggle unvisited Node to a Wall Node\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (this.state.startNodePressed) { // Toggle Node at (row, col) to start Node\r\n      console.log(`mouse ENTER row:${row}  col:${col}`);\r\n      this.setState({\r\n        start: { row: row, col: col },\r\n      });\r\n    }\r\n    if (this.state.finishNodePressed) { // Toggle Node at (row, col) to finish Node\r\n      this.setState({\r\n        finish: { row: row, col: col },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Animate the Nodes in the grid according to order \r\n   * in which they have been visited by the algorithm\r\n   * @param {Node[]} visitedNodesInOrder Array of Nodes visited in order\r\n   * @param {Node[]} nodesInShortestPathOrder  Array of Nodes in the shortest path\r\n   */\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n\r\n    // Traverse the visitedNodesInOrder array and set each Node to visited\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      // If it is the last Node then animate the shortest path\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, singleAnimationDuration * i);\r\n        return;\r\n      }\r\n\r\n      // Set Node to visited and change its HTML class\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, singleAnimationDuration * i);\r\n\r\n      // Increase the visited Nodes count\r\n      this.setState({ visited: i + 1 });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Animates the Nodes in the shortest path from start to end Node\r\n   * @param {Node[]} nodesInShortestPathOrder Array of Nodes in the shortest path\r\n   */\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n\r\n    // Shortest path length must be greater than 1 for an animation to happen\r\n    // There's nothing to animate if the start and end Nodes are adjacent\r\n    if (nodesInShortestPathOrder.length > 1) {\r\n      // Traverse through the array and set each Node to the 'node-shortest-path' HTML class\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }, singleAnimationDuration * i);\r\n\r\n        // Increase the counted Nodes count\r\n        this.setState({ counted: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Visualizes the chosen algorithm\r\n   */\r\n  visualize() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start.row][this.state.start.col];\r\n    const finishNode = grid[this.state.finish.row][this.state.finish.col];\r\n    // const visitedNodesInOrder =\r\n    //   this.state.algorithm === \"Dijkstra's\"\r\n    //     ? dijkstra(grid, startNode, finishNode)\r\n    //     : astar(grid, startNode, finishNode);\r\n\r\n    let visitedNodesInOrder = [];\r\n    switch (this.state.algorithm) {\r\n      case \"Dijkstra's\":\r\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n        break;\r\n      case \"A*\":\r\n        visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // Get the nodes in the shortest path\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n\r\n    // Animate the algorithm\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  /**\r\n   * @description Generates wall Nodes randomly\r\n   */\r\n  generateRandomMaze() {\r\n    //const rows = 20, cols = 50;\r\n    const {numRows, numCols} = this.state;\r\n    let newGrid = [];\r\n    for (let i = 0; i < Math.floor(Math.random() * numCols * numRows); i++) {\r\n      const randomRow = Math.floor(Math.random() * numRows);\r\n      const randomCol = Math.floor(Math.random() * numCols);\r\n      if (\r\n        (randomRow !== this.state.start.row ||\r\n          randomCol !== this.state.start.col) &&\r\n        (randomRow !== this.state.finish.row ||\r\n          randomCol !== this.state.finish.col)\r\n      ) {\r\n        //console.log(`randomRow: ${randomRow} randomCol: ${randomCol}`);\r\n        newGrid = this.getNewGridWithWallToggled(\r\n          this.state.grid,\r\n          randomRow,\r\n          randomCol\r\n        );\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Sets the chosen algorithm. By default it is \"Dijkstra's\"\r\n   * @param {*} event \r\n   */\r\n  setAlgorithm(event) {\r\n    const { name, value } = event.target;\r\n    this.setState({ [name]: value });\r\n  }\r\n\r\n  /**\r\n   * @description Sets the chosen speed. By default it is \"Fast\", ie. 10ms\r\n   * @param {*} event \r\n   */\r\n  setSpeed(event) {\r\n    const { name, value } = event.target;\r\n    value === \"Fast\"\r\n      ? this.setState({ [name]: value, speedSeconds: 10 })\r\n      : value === \"Average\"\r\n      ? this.setState({ [name]: value, speedSeconds: 50 })\r\n      : this.setState({ [name]: value, speedSeconds: 100 });\r\n  }\r\n\r\n  /**\r\n   * @description Shows the dimensions of the 'window' and of 'root'\r\n   */\r\n  showWidth() {\r\n    console.log(\r\n      `window.width: ${window.innerWidth} window.innerHeight: ${window.innerHeight}`\r\n    );\r\n    var root = document.getElementById(\"root\");\r\n    console.log(\r\n      `root.clientWidth: ${root.clientWidth} root.clientHeight: ${root.clientHeight}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @description Resets the grid WITHOUT reloading the page\r\n   */\r\n  reset(){\r\n    const {grid, numRows, numCols} = this.state;\r\n    for (let row = 0; row < numRows; row++) {\r\n      for (let col = 0; col < numCols; col++) {\r\n        if (grid[row][col].isStart) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\r\n        } else if (grid[row][col].isFinish) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\r\n        } else {\r\n          if(grid[row][col].isWall) grid[row][col].isWall = false\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({grid, visited: 0, counted: 0})\r\n  }\r\n\r\n  /**\r\n   * @description Resets the grid by reloading the page\r\n   */\r\n  // reset2() {\r\n  //   //Hacky\r\n  //   window.location.reload(false);\r\n  // }\r\n\r\n  render() {\r\n    const { grid, visited, counted } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <div id=\"navbar\">\r\n          <h1>Pathfinding Visualizer</h1>\r\n          <div id=\"counters\">\r\n            <h2>Nodes visited: {visited}</h2>\r\n            <h2>Nodes counted: {counted}</h2>\r\n          </div>\r\n          <div>\r\n            <select\r\n              id=\"algo_dropdown\"\r\n              name=\"algorithm\"\r\n              value={this.state.algorithm}\r\n              onChange={this.setAlgorithm}\r\n            >\r\n              <option value=\"Dijkstra's\">Diijkstra's</option>\r\n              <option value=\"A*\">A*</option>\r\n            </select>\r\n            <button id=\"btn\" onClick={() => this.visualize()}>\r\n              Visualize {this.state.algorithm}\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.generateRandomMaze()}>\r\n              Generate Random Walls\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.reset()}>\r\n              Reset\r\n            </button>\r\n            <select\r\n              id=\"speed_dropdown\"\r\n              name=\"speedText\"\r\n              value={this.state.speedText}\r\n              onChange={this.setSpeed}\r\n            >\r\n              <option value=\"Fast\">Fast</option>\r\n              <option value=\"Average\">Average</option>\r\n              <option value=\"Slow\">Slow</option>\r\n            </select>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    //isVisited,\r\n                    isWall,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      //isVisited={isVisited} //Uncommenting this causes the whole animation to render at once for some reason\r\n                      isWall={isWall}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\n//import PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n//import PathfindingVisualizer2 from \"./PathfindingVisualizer/PathfindingVisualizer2\";\nimport PathfindingVisualizer3 from \"./PathfindingVisualizer/PathfindingVisualizer3\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer3></PathfindingVisualizer3>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}