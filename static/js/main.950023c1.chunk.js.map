{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/astar.js","algorithms/dijkstras.js","PathfindingVisualizer/PathfindingVisualizer3.jsx","App.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isVisited","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","id","className","React","Component","ManhattanDistance","currentNode","targetNode","Math","abs","sortNodesByFScore","grid","sort","nodeA","nodeB","fscore","getUnvisitedNeighbours","node","neighbours","push","length","filter","neighbour","updateUnvisitedNeighbours","distance","previousNode","dijkstra","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","pop","PathfindingVisualizer3","getInitialGrid","navbarHeight","document","getElementById","clientHeight","numCols","floor","window","innerWidth","numRows","innerHeight","console","log","currentRow","createNode","algorithm","mouseIsPressed","startNodePressed","finishNodePressed","start","finish","speedText","speedSeconds","prevNode","visited","counted","animateAlgorithm","bind","handleMouseDown","handleMouseUp","handleMouseEnter","setSpeed","setAlgorithm","setState","gscore","hscore","newGrid","slice","newNode","type","getNewGridWithNodeToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","singleAnimationDuration","i","setTimeout","animateShortestPath","closedList","openList","includes","astar","unshift","getNodesInShortestPathOrder","random","randomRow","randomCol","event","target","name","value","root","clientWidth","location","reload","onChange","onClick","visualize","generateRandomMaze","reset","map","rowIdx","key","nodeIdx","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.950023c1.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseUp,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export function astar(grid, startNode, finishNode) {\r\n  const closedList = [];\r\n  const openList = [startNode]; //getAllNodes(grid);\r\n  //openList.unshift(startNode);\r\n  startNode.gscore = 0;\r\n  startNode.fscore = ManhattanDistance(startNode, finishNode);\r\n\r\n  while (!!openList.length) {\r\n    sortNodesByFScore(openList);\r\n    const currentNode = openList.shift();\r\n    console.log(`currentNode: ${currentNode.col} ${currentNode.row}`);\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    //if (currentNode.distance === Infinity) return false;\r\n\r\n    if (currentNode === finishNode) {\r\n      console.log(\"closedList: \", closedList);\r\n      return closedList;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    closedList.push(currentNode);\r\n\r\n    const neighbours = getUnvisitedNeighbours(currentNode, grid);\r\n    for (const neighbour of neighbours) {\r\n      if (!closedList.includes(neighbour)) {\r\n        neighbour.gscore = currentNode.gscore + 1; //1 is the distance between currentNode and neighbour\r\n        neighbour.hscore = ManhattanDistance(neighbour, finishNode);\r\n        neighbour.fscore = neighbour.gscore + neighbour.hscore;\r\n\r\n        if (!openList.includes(neighbour)) {\r\n          openList.push(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    updateUnvisitedNeighbours(currentNode, grid);\r\n  }\r\n}\r\n\r\nfunction ManhattanDistance(currentNode, targetNode) {\r\n  const temp =\r\n    Math.abs(currentNode.col - targetNode.col) +\r\n    Math.abs(currentNode.row - targetNode.row);\r\n  return temp;\r\n}\r\n\r\nfunction sortNodesByFScore(grid) {\r\n  grid.sort((nodeA, nodeB) => nodeA.fscore - nodeB.fscore);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  /*\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    //Exceptional case with no startNode, no finishNode, or when they're equal\r\n    return false;\r\n  } */\r\n\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (!!unvisitedNodes.length) {\r\n    //Double negation meaning?\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift(); //removes closestNode from unvisitedNodes\r\n\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    if (closestNode.distance === Infinity) {\r\n      //When there are NO valid paths. Eg. walls around source or target\r\n      visitedNodesInOrder.pop();\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); //Absolute value?\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { astar } from \"../algorithms/astar\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/dijkstras.js\";\r\n\r\nexport default class PathfindingVisualizer3 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      algorithm: \"Dijkstra's\",\r\n      mouseIsPressed: false,\r\n      startNodePressed: false,\r\n      finishNodePressed: false,\r\n      start: { col: 5, row: 10 },\r\n      finish: { col: 20, row: 10 },\r\n      speedText: \"Fast\",\r\n      speedSeconds: 10,\r\n      prevNode: null,\r\n      visited: 0,\r\n      counted: 0,\r\n    };\r\n    this.animateAlgorithm = this.animateAlgorithm.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.setSpeed = this.setSpeed.bind(this);\r\n    this.setAlgorithm = this.setAlgorithm.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  getInitialGrid = () => {\r\n    var navbarHeight = document.getElementById(\"navbar\").clientHeight;\r\n    const grid = [];\r\n    const numCols = Math.floor((window.innerWidth - 160) / 40);\r\n    const numRows = Math.floor((window.innerHeight - navbarHeight - 120) / 40);\r\n    console.log(`numCols: ${numCols} numRows: ${numRows}`);\r\n    for (let row = 0; row < numRows; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < numCols; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start.row && col === this.state.start.col,\r\n      isFinish: row === this.state.finish.row && col === this.state.finish.col,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      gscore: 0,\r\n      hscore: 0,\r\n      fscore: 0,\r\n    };\r\n  }\r\n\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  getNewGridWithNodeToggled(type, grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: type === \"start\" ? !node.isStart : node.isStart,\r\n      isFinish: type === \"finish\" ? !node.isFinish : node.isFinish,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (row === this.state.start.row && col === this.state.start.col) {\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        startNodePressed: true,\r\n      });\r\n    } else if (row === this.state.finish.row && col === this.state.finish.col) {\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        finishNodePressed: true,\r\n      });\r\n    } else {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    //Originally there was no row, col being passed\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse UP row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        start: { row: row, col: col },\r\n        startNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else if (this.state.finishNodePressed) {\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        finish: { row: row, col: col },\r\n        finishNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else {\r\n      this.setState({ mouseIsPressed: false });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (\r\n      this.state.mouseIsPressed &&\r\n      !this.state.startNodePressed &&\r\n      !this.state.finishNodePressed\r\n    ) {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse ENTER row:${row}  col:${col}`);\r\n      this.setState({\r\n        start: { row: row, col: col },\r\n      });\r\n    }\r\n    if (this.state.finishNodePressed) {\r\n      this.setState({\r\n        finish: { row: row, col: col },\r\n      });\r\n    }\r\n  }\r\n\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, singleAnimationDuration * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, singleAnimationDuration * i);\r\n      this.setState({ visited: i + 1 });\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n    if (nodesInShortestPathOrder.length > 1) {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }, singleAnimationDuration * i);\r\n        this.setState({ counted: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  visualize() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start.row][this.state.start.col];\r\n    const finishNode = grid[this.state.finish.row][this.state.finish.col];\r\n    const visitedNodesInOrder =\r\n      this.state.algorithm === \"Dijkstra's\"\r\n        ? dijkstra(grid, startNode, finishNode)\r\n        : astar(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  generateRandomMaze() {\r\n    const rows = 20,\r\n      cols = 50;\r\n    let newGrid = [];\r\n    for (let i = 0; i < Math.floor(Math.random() * cols * rows); i++) {\r\n      const randomRow = Math.floor(Math.random() * rows);\r\n      const randomCol = Math.floor(Math.random() * cols);\r\n      if (\r\n        (randomRow !== this.state.start.row ||\r\n          randomCol !== this.state.start.col) &&\r\n        (randomRow !== this.state.finish.row ||\r\n          randomCol !== this.state.finish.col)\r\n      ) {\r\n        //console.log(`randomRow: ${randomRow} randomCol: ${randomCol}`);\r\n        newGrid = this.getNewGridWithWallToggled(\r\n          this.state.grid,\r\n          randomRow,\r\n          randomCol\r\n        );\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  }\r\n\r\n  setAlgorithm(event) {\r\n    const { name, value } = event.target;\r\n    this.setState({ [name]: value });\r\n  }\r\n\r\n  setSpeed(event) {\r\n    const { name, value } = event.target;\r\n    value === \"Fast\"\r\n      ? this.setState({ [name]: value, speedSeconds: 10 })\r\n      : value === \"Average\"\r\n      ? this.setState({ [name]: value, speedSeconds: 50 })\r\n      : this.setState({ [name]: value, speedSeconds: 100 });\r\n  }\r\n\r\n  showWidth() {\r\n    console.log(\r\n      `window.width: ${window.innerWidth} window.innerHeight: ${window.innerHeight}`\r\n    );\r\n    var root = document.getElementById(\"root\");\r\n    console.log(\r\n      `root.clientWidth: ${root.clientWidth} root.clientHeight: ${root.clientHeight}`\r\n    );\r\n  }\r\n\r\n  reset() {\r\n    //Hacky\r\n    window.location.reload(false);\r\n  }\r\n\r\n  render() {\r\n    const { grid, visited, counted } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <div id=\"navbar\">\r\n          <h1>Pathfinding Visualizer</h1>\r\n          <div id=\"counters\">\r\n            <h2>Nodes visited: {visited}</h2>\r\n            <h2>Nodes counted: {counted}</h2>\r\n          </div>\r\n          <div>\r\n            <select\r\n              id=\"algo_dropdown\"\r\n              name=\"algorithm\"\r\n              value={this.state.algorithm}\r\n              onChange={this.setAlgorithm}\r\n            >\r\n              <option value=\"Dijkstra's\">Diijkstra's</option>\r\n              <option value=\"A*\">A*</option>\r\n            </select>\r\n            <button id=\"btn\" onClick={() => this.visualize()}>\r\n              Visualize {this.state.algorithm}\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.generateRandomMaze()}>\r\n              Generate Random Walls\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.reset()}>\r\n              Reset\r\n            </button>\r\n            <select\r\n              id=\"speed_dropdown\"\r\n              name=\"speedText\"\r\n              value={this.state.speedText}\r\n              onChange={this.setSpeed}\r\n            >\r\n              <option value=\"Fast\">Fast</option>\r\n              <option value=\"Average\">Average</option>\r\n              <option value=\"Slow\">Slow</option>\r\n            </select>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    //isVisited,\r\n                    isWall,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      //isVisited={isVisited} //Uncommenting this causes the whole animation to render at once for some reason\r\n                      isWall={isWall}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\n//import PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n//import PathfindingVisualizer2 from \"./PathfindingVisualizer/PathfindingVisualizer2\";\nimport PathfindingVisualizer3 from \"./PathfindingVisualizer/PathfindingVisualizer3\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer3></PathfindingVisualizer3>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}