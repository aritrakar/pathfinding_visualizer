{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","algorithms/dijkstras.js","PathfindingVisualizer/PathfindingVisualizer.jsx","PathfindingVisualizer/PathfindingVisualizer2.jsx","App.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isVisited","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","id","className","React","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","nodes","node","push","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","pop","updateUnvisitedNeighbours","neighbours","filter","neighbour","getUnvisitedNeighbours","previousNode","sort","nodeA","nodeB","getNodesInShortestPathOrder","nodesInShortestPathOrder","currentNode","unshift","PathfindingVisualizer2","getInitialGrid","currentRow","createNode","mouseIsPressed","startNodePressed","finishNodePressed","start","finish","prevNode","visited","counted","visualizeDijkstra","bind","animateDijkstra","handleMouseDown","handleMouseUp","handleMouseEnter","setState","console","log","newGrid","getNewGridWithNodeToggled","getNewGridWithWallToggled","slice","newNode","type","i","setTimeout","animateShortestPath","document","getElementById","Math","floor","random","randomRow","randomCol","onClick","generateRandomMaze","reset","map","rowIdx","key","nodeIdx","App","ReactDOM","render"],"mappings":"yVAGqBA,G,wDACnB,WAAYC,GAAQ,IAAD,8BACjB,cAAMA,IACDC,MAAQ,GAFI,E,qDAIT,IAAD,EAWHC,KAAKF,MATPG,EAFK,EAELA,IACAC,EAHK,EAGLA,IACAC,EAJK,EAILA,QACAC,EALK,EAKLA,SACAC,EANK,EAMLA,UACAC,EAPK,EAOLA,OACAC,EARK,EAQLA,UACAC,EATK,EASLA,YACAC,EAVK,EAULA,aAEIC,EAAiBN,EACnB,cACAD,EACA,aACAG,EACA,YACAD,EACA,eACA,GACJ,OACE,yBACEM,GAAE,eAAUV,EAAV,YAAiBC,GACnBU,UAAS,eAAUF,GACnBF,YAAa,kBAAMA,EAAYP,EAAKC,IACpCO,aAAc,kBAAMA,EAAaR,EAAKC,IACtCK,UAAW,kBAAMA,EAAUN,EAAKC,U,GAhCNW,IAAMC,Y,cCHjC,SAASC,EAASC,EAAMC,EAAWC,GAOxC,IAAMC,EAAsB,GAC5BF,EAAUG,SAAW,EAGrB,IAFA,IAAMC,EA0BR,SAAqBL,GACnB,IADyB,EACnBM,EAAQ,GADW,cAEPN,GAFO,IAEzB,2BAAwB,CAAC,IAAD,EAAbf,EAAa,sBACHA,GADG,IACtB,2BAAwB,CAAC,IAAdsB,EAAa,QACtBD,EAAME,KAAKD,IAFS,gCAFC,8BAOzB,OAAOD,EAjCgBG,CAAYT,GAE1BK,EAAeK,QAAQ,CAE9BC,EAAoBN,GACpB,IAAMO,EAAcP,EAAeQ,QAEnC,IAAID,EAAYtB,OAAhB,CAGA,GAAIsB,EAAYR,WAAaU,IAG3B,OADAX,EAAoBY,MACbZ,EAMT,GAHAS,EAAYvB,WAAY,EACxBc,EAAoBK,KAAKI,GAErBA,IAAgBV,EAClB,OAAOC,EAETa,EAA0BJ,EAAaZ,KAoC3C,SAASgB,EAA0BT,EAAMP,GACvC,IAD6C,EACvCiB,EAvBR,SAAgCV,EAAMP,GACpC,IAAMiB,EAAa,GACX/B,EAAaqB,EAAbrB,IAAKD,EAAQsB,EAARtB,IAiBb,OAfIA,EAAM,GACRgC,EAAWT,KAAKR,EAAKf,EAAM,GAAGC,IAG5BD,EAAMe,EAAKU,OAAS,GACtBO,EAAWT,KAAKR,EAAKf,EAAM,GAAGC,IAG5BA,EAAM,GACR+B,EAAWT,KAAKR,EAAKf,GAAKC,EAAM,IAG9BA,EAAMc,EAAKf,GAAKyB,OAAS,GAC3BO,EAAWT,KAAKR,EAAKf,GAAKC,EAAM,IAE3B+B,EAAWC,QAAO,SAACC,GAAD,OAAgBA,EAAU9B,aAIhC+B,CAAuBb,EAAMP,GADH,cAErBiB,GAFqB,IAE7C,2BAAoC,CAAC,IAA1BE,EAAyB,QAClCA,EAAUf,SAAWG,EAAKH,SAAW,EACrCe,EAAUE,aAAed,GAJkB,+BAQ/C,SAASI,EAAoBN,GAC3BA,EAAeiB,MAAK,SAACC,EAAOC,GAAR,OAAkBD,EAAMnB,SAAWoB,EAAMpB,YAKxD,SAASqB,EAA4BvB,GAG1C,IAFA,IAAMwB,EAA2B,GAC7BC,EAAczB,EACK,OAAhByB,GACLD,EAAyBE,QAAQD,GACjCA,EAAcA,EAAYN,aAE5B,OAAOK,ECzE2B7B,IAAMC,U,ICPrB+B,E,kDACnB,WAAY/C,GAAQ,IAAD,8BACjB,cAAMA,IAwBRgD,eAAiB,WAEf,IADA,IAAM9B,EAAO,GACJf,EAAM,EAAGA,EAAM,GAAIA,IAAO,CAEjC,IADA,IAAM8C,EAAa,GACV7C,EAAM,EAAGA,EAAM,GAAIA,IAC1B6C,EAAWvB,KAAK,EAAKwB,WAAW9C,EAAKD,IAEvCe,EAAKQ,KAAKuB,GAEZ,OAAO/B,GAhCP,EAAKjB,MAAQ,CACXiB,KAAM,GACNiC,gBAAgB,EAChBC,kBAAkB,EAClBC,mBAAmB,EACnBC,MAAO,CAAElD,IAAK,EAAGD,IAAK,IACtBoD,OAAQ,CAAEnD,IAAK,GAAID,IAAK,IACxBqD,SAAU,KACVC,QAAS,EACTC,QAAS,GAEX,EAAKC,kBAAoB,EAAKA,kBAAkBC,KAAvB,gBACzB,EAAKC,gBAAkB,EAAKA,gBAAgBD,KAArB,gBACvB,EAAKE,gBAAkB,EAAKA,gBAAgBF,KAArB,gBACvB,EAAKG,cAAgB,EAAKA,cAAcH,KAAnB,gBACrB,EAAKI,iBAAmB,EAAKA,iBAAiBJ,KAAtB,gBAjBP,E,gEAqBjB,IAAM1C,EAAOhB,KAAK8C,iBAClB9C,KAAK+D,SAAS,CAAE/C,KAAMA,M,iCAebd,EAAKD,GACd,MAAO,CACLC,MACAD,MACAE,QAASF,IAAQD,KAAKD,MAAMqD,MAAMnD,KAAOC,IAAQF,KAAKD,MAAMqD,MAAMlD,IAClEE,SAAUH,IAAQD,KAAKD,MAAMsD,OAAOpD,KAAOC,IAAQF,KAAKD,MAAMsD,OAAOnD,IACrEkB,SAAUU,IACVzB,WAAW,EACXC,QAAQ,EACR+B,aAAc,Q,sCAIFpC,EAAKC,GACnB,GAAID,IAAQD,KAAKD,MAAMqD,MAAMnD,KAAOC,IAAQF,KAAKD,MAAMqD,MAAMlD,IAAK,CAChE8D,QAAQC,IAAR,yBAA8BhE,EAA9B,iBAA0CC,IAC1C,IAAMgE,EAAUlE,KAAKmE,0BACnB,QACAnE,KAAKD,MAAMiB,KACXf,EACAC,GAEFF,KAAK+D,SAAS,CACZ/C,KAAMkD,EACNjB,gBAAgB,EAChBC,kBAAkB,SAEf,GAAIjD,IAAQD,KAAKD,MAAMsD,OAAOpD,KAAOC,IAAQF,KAAKD,MAAMsD,OAAOnD,IAAK,CACzE8D,QAAQC,IAAR,yBAA8BhE,EAA9B,iBAA0CC,IAE1C,IAAMgE,EAAUlE,KAAKmE,0BACnB,SACAnE,KAAKD,MAAMiB,KACXf,EACAC,GAEFF,KAAK+D,SAAS,CACZ/C,KAAMkD,EACNjB,gBAAgB,EAChBE,mBAAmB,QAEhB,CACL,IAAMe,EAAUlE,KAAKoE,0BAA0BpE,KAAKD,MAAMiB,KAAMf,EAAKC,GACrEF,KAAK+D,SAAS,CAAE/C,KAAMkD,EAASjB,gBAAgB,O,oCAIrChD,EAAKC,GAEjB,GAAIF,KAAKD,MAAMmD,iBAAkB,CAC/Bc,QAAQC,IAAR,uBAA4BhE,EAA5B,iBAAwCC,IACxC,IAAMgE,EAAUlE,KAAKmE,0BACnB,QACAnE,KAAKD,MAAMiB,KACXf,EACAC,GAEFF,KAAK+D,SAAS,CACZ/C,KAAMkD,EACNd,MAAO,CAAEnD,IAAKA,EAAKC,IAAKA,GACxBgD,kBAAkB,EAClBD,gBAAgB,SAEb,GAAIjD,KAAKD,MAAMoD,kBAAmB,CACvC,IAAMe,EAAUlE,KAAKmE,0BACnB,SACAnE,KAAKD,MAAMiB,KACXf,EACAC,GAEFF,KAAK+D,SAAS,CACZ/C,KAAMkD,EACNb,OAAQ,CAAEpD,IAAKA,EAAKC,IAAKA,GACzBiD,mBAAmB,EACnBF,gBAAgB,SAGlBjD,KAAK+D,SAAS,CAAEd,gBAAgB,M,uCAInBhD,EAAKC,GACpB,GAAKF,KAAKD,MAAMkD,eAAhB,CACA,GACEjD,KAAKD,MAAMkD,iBACVjD,KAAKD,MAAMmD,mBACXlD,KAAKD,MAAMoD,kBACZ,CACA,IAAMe,EAAUlE,KAAKoE,0BAA0BpE,KAAKD,MAAMiB,KAAMf,EAAKC,GACrEF,KAAK+D,SAAS,CAAE/C,KAAMkD,IAEpBlE,KAAKD,MAAMmD,mBACbc,QAAQC,IAAR,0BAA+BhE,EAA/B,iBAA2CC,IAC3CF,KAAK+D,SAAS,CACZX,MAAO,CAAEnD,IAAKA,EAAKC,IAAKA,MAGxBF,KAAKD,MAAMoD,mBACbnD,KAAK+D,SAAS,CACZV,OAAQ,CAAEpD,IAAKA,EAAKC,IAAKA,Q,gDAKLc,EAAMf,EAAKC,GACnC,IAAMgE,EAAUlD,EAAKqD,QACf9C,EAAO2C,EAAQjE,GAAKC,GACpBoE,EAAO,2BACR/C,GADQ,IAEXjB,QAASiB,EAAKjB,SAGhB,OADA4D,EAAQjE,GAAKC,GAAOoE,EACbJ,I,gDAGiBK,EAAMvD,EAAMf,EAAKC,GACzC,IAAMgE,EAAUlD,EAAKqD,QACf9C,EAAO2C,EAAQjE,GAAKC,GACpBoE,EAAO,2BACR/C,GADQ,IAEXpB,QAAkB,UAAToE,GAAoBhD,EAAKpB,QAAUoB,EAAKpB,QACjDC,SAAmB,WAATmE,GAAqBhD,EAAKnB,SAAWmB,EAAKnB,WAGtD,OADA8D,EAAQjE,GAAKC,GAAOoE,EACbJ,I,sCAGO/C,EAAqBuB,GACnC,IAD8D,IAAD,kBACpD8B,GACP,GAAIA,IAAMrD,EAAoBO,OAI5B,OAHA+C,YAAW,WACT,EAAKC,oBAAoBhC,KACxB,GAAK8B,GACF,CAAN,UAEFC,YAAW,WACT,IAAMlD,EAAOJ,EAAoBqD,GACjCG,SAASC,eAAT,eAAgCrD,EAAKtB,IAArC,YAA4CsB,EAAKrB,MAAOU,UACtD,sBACD,GAAK4D,GACR,EAAKT,SAAS,CAAER,QAASiB,EAAI,KAZtBA,EAAI,EAAGA,GAAKrD,EAAoBO,OAAQ8C,IAAK,CAAC,IAAD,IAA7CA,GAA6C,qC,0CAgBpC9B,GAA2B,IAAD,OAC5C,GAAIA,EAAyBhB,OAAS,EACpC,IADwC,IAAD,WAC9B8C,GACPC,YAAW,WACT,IAAMlD,EAAOmB,EAAyB8B,GACtCG,SAASC,eAAT,eAAgCrD,EAAKtB,IAArC,YAA4CsB,EAAKrB,MAAOU,UACtD,4BACD,GAAK4D,GACR,EAAKT,SAAS,CAAEP,QAASgB,EAAI,KANtBA,EAAI,EAAGA,EAAI9B,EAAyBhB,OAAQ8C,IAAM,EAAlDA,K,0CAWQ,IACXxD,EAAShB,KAAKD,MAAdiB,KACFC,EAAYD,EAAKhB,KAAKD,MAAMqD,MAAMnD,KAAKD,KAAKD,MAAMqD,MAAMlD,KACxDgB,EAAaF,EAAKhB,KAAKD,MAAMsD,OAAOpD,KAAKD,KAAKD,MAAMsD,OAAOnD,KAC3DiB,EAAsBJ,EAASC,EAAMC,EAAWC,GAChDwB,EAA2BD,EAA4BvB,GAC7DlB,KAAK2D,gBAAgBxC,EAAqBuB,K,2CAO1C,IAHA,IAEIwB,EAAU,GACLM,EAAI,EAAGA,EAAIK,KAAKC,MAFhB,GAEsBD,KAAKE,SAHvB,IAGgDP,IAAK,CAChE,IAAMQ,EAAYH,KAAKC,MAJZ,GAIkBD,KAAKE,UAC5BE,EAAYJ,KAAKC,MAJhB,GAIsBD,KAAKE,UAE/BC,IAAchF,KAAKD,MAAMqD,MAAMnD,KAC9BgF,IAAcjF,KAAKD,MAAMqD,MAAMlD,KAChC8E,IAAchF,KAAKD,MAAMsD,OAAOpD,KAC/BgF,IAAcjF,KAAKD,MAAMsD,OAAOnD,MAElC8D,QAAQC,IAAR,qBAA0Be,EAA1B,uBAAkDC,IAClDf,EAAUlE,KAAKoE,0BACbpE,KAAKD,MAAMiB,KACXgE,EACAC,GAEFjF,KAAK+D,SAAS,CAAE/C,KAAMkD,Q,8BAM1B,IAAMlD,EAAOhB,KAAK8C,iBAClB9C,KAAK+D,SAAS,CAAE/C,KAAMA,M,+BAGd,IAAD,SAC4BhB,KAAKD,MAAhCiB,EADD,EACCA,KAAMuC,EADP,EACOA,QAASC,EADhB,EACgBA,QAEvB,OACE,6BACE,sDACA,yBAAK7C,GAAG,YACN,8CAAoB4C,GACpB,8CAAoBC,IAEtB,6BACE,4BAAQ7C,GAAG,MAAMuE,QAAS,kBAAM,EAAKzB,sBAArC,kCAGA,4BAAQ9C,GAAG,MAAMuE,QAAS,kBAAM,EAAKC,uBAArC,yBAGA,4BAAQxE,GAAG,MAAMuE,QAAS,kBAAM,EAAKE,UAArC,UAKF,yBAAKxE,UAAU,QACZI,EAAKqE,KAAI,SAACpF,EAAKqF,GACd,OACE,yBAAKC,IAAKD,GACPrF,EAAIoF,KAAI,SAAC9D,EAAMiE,GAAa,IAEzBvF,EAMEsB,EANFtB,IACAC,EAKEqB,EALFrB,IACAC,EAIEoB,EAJFpB,QACAC,EAGEmB,EAHFnB,SAEAE,EACEiB,EADFjB,OAEF,OACE,kBAAC,EAAD,CACEiF,IAAKC,EACLvF,IAAKA,EACLC,IAAKA,EACLC,QAASA,EACTC,SAAUA,EAEVE,OAAQA,EACRE,YAAa,SAACP,EAAKC,GAAN,OAAc,EAAK0D,gBAAgB3D,EAAKC,IACrDO,aAAc,SAACR,EAAKC,GAAN,OACZ,EAAK4D,iBAAiB7D,EAAKC,IAE7BK,UAAW,SAACN,EAAKC,GAAN,OAAc,EAAK2D,cAAc5D,EAAKC,mB,GAzRnBW,IAAMC,WCK3C2E,MARf,WACE,OACE,yBAAK7E,UAAU,OACb,kBAAC,EAAD,QCHN8E,IAASC,OACP,kBAAC,EAAD,MACAhB,SAASC,eAAe,W","file":"static/js/main.1f75d3d4.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseUp,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","export function dijkstra(grid, startNode, finishNode) {\r\n  /*\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    //Exceptional case with no startNode, no finishNode, or when they're equal\r\n    return false;\r\n  } */\r\n\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  while (!!unvisitedNodes.length) {\r\n    //Double negation meaning?\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift(); //removes closestNode from unvisitedNodes\r\n\r\n    if (closestNode.isWall) {\r\n      continue;\r\n    }\r\n    if (closestNode.distance === Infinity) {\r\n      //When there are NO valid paths. Eg. walls around source or target\r\n      visitedNodesInOrder.pop();\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\nfunction getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter((neighbour) => !neighbour.isVisited);\r\n}\r\n\r\nfunction updateUnvisitedNeighbours(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); //Absolute value?\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/dijkstras.js\";\r\n\r\n/*\r\nconst START_NODE_COL = 37;\r\nconst START_NODE_ROW = 15;\r\nconst FINISH_NODE_COL = 45;\r\nconst FINISH_NODE_ROW = 10;\r\n*/\r\n\r\nclass PathfindingVisualizer extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      startNodePressed: false,\r\n      finishNodePressed: false,\r\n      start: { col: 5, row: 10 },\r\n      finish: { col: 45, row: 10 },\r\n      prevNode: null,\r\n      visited: 0,\r\n      counted: 0,\r\n    };\r\n    this.visualizeDijkstra = this.visualizeDijkstra.bind(this);\r\n    this.animateDijkstra = this.animateDijkstra.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    //this.getNewGridWithWallToggled = this.getNewGridWithWallToggled.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start.row && col === this.state.start.col, //START_NODE_ROW  START_NODE_COL,\r\n      isFinish: row === this.state.finish.row && col === this.state.finish.col, //FINISH_NODE_ROW  FINISH_NODE_COL\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    //console.log(`DOWN. row: ${row} col: ${col}`);\r\n    if (row === this.state.start.row && col === this.state.start.col) {\r\n      //const prevNode = this.state.grid[row][col];\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n      //document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        startNodePressed: true,\r\n      });\r\n    } else if (row === this.state.finish.row && col === this.state.finish.col) {\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        finishNodePressed: true,\r\n      });\r\n    } else {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    //Originally there was no row, col being passed\r\n    //console.log(\"mouse UP\");\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse UP row:${row}  col:${col}`);\r\n      //document.getElementById(`node-${row}-${col}`).className =\"node node-start\";\r\n\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n\r\n      this.setState({\r\n        grid: newGrid,\r\n        start: { row: row, col: col },\r\n        startNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n      console.log(\"this.state.start: \", this.state.start);\r\n    } else if (this.state.finishNodePressed) {\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n\r\n      this.setState({\r\n        grid: newGrid,\r\n        finish: { row: row, col: col },\r\n        finishNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else {\r\n      console.log(\"startNodePressed === false\");\r\n      this.setState({ mouseIsPressed: false });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (\r\n      this.state.mouseIsPressed &&\r\n      !this.state.startNodePressed &&\r\n      !this.state.finishNodePressed\r\n    ) {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse ENTER row:${row}  col:${col}`);\r\n      this.setState({\r\n        start: { row: row, col: col },\r\n      });\r\n    }\r\n    if (this.state.finishNodePressed) {\r\n      this.setState({\r\n        finish: { row: row, col: col },\r\n      });\r\n    }\r\n  }\r\n\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  getNewGridWithNodeToggled(type, grid, row, col) {\r\n    //For source\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: type === \"start\" ? !node.isStart : node.isStart,\r\n      isFinish: type === \"finish\" ? !node.isFinish : node.isFinish,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n      this.setState({ visited: i + 1 });\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    if (nodesInShortestPathOrder.length > 1) {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }, 10 * i);\r\n        this.setState({ counted: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start.row][this.state.start.col]; //START_NODE_ROW START_NODE_COL\r\n    const finishNode = grid[this.state.finish.row][this.state.finish.col]; //FINISH_NODE_ROW  FINISH_NODE_COL\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  generateRandomMaze() {\r\n    const rows = 20,\r\n      cols = 50;\r\n    let newGrid = [];\r\n    for (let i = 0; i < Math.floor(Math.random() * cols * rows); i++) {\r\n      const randomRow = Math.floor(Math.random() * rows);\r\n      const randomCol = Math.floor(Math.random() * cols);\r\n      if (\r\n        (randomRow !== this.state.start.row ||\r\n          randomCol !== this.state.start.col) &&\r\n        (randomRow !== this.state.finish.row ||\r\n          randomCol !== this.state.finish.col)\r\n      ) {\r\n        console.log(`randomRow: ${randomRow} randomCol: ${randomCol}`);\r\n        newGrid = this.getNewGridWithWallToggled(\r\n          this.state.grid,\r\n          randomRow,\r\n          randomCol\r\n        );\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  render() {\r\n    const { grid, visited, counted } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <h1>Pathfinding Visualizer</h1>\r\n        <div id=\"counters\">\r\n          <h2>Nodes visited: {visited}</h2>\r\n          <h2>Nodes counted: {counted}</h2>\r\n        </div>\r\n        <div>\r\n          <button id=\"btn\" onClick={() => this.visualizeDijkstra()}>\r\n            Visualize Dijkstra's algorithm\r\n          </button>\r\n          <button id=\"btn\" onClick={() => this.generateRandomMaze()}>\r\n            Generate Random Walls\r\n          </button>\r\n          <button id=\"btn\" onClick={() => this.reset()}>\r\n            Reset\r\n          </button>\r\n        </div>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    //isVisited,\r\n                    isWall,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      //isVisited={isVisited} //Uncommenting this causes the whole animation to render at once for some reason\r\n                      isWall={isWall}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default PathfindingVisualizer;\r\n","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport {\r\n  dijkstra,\r\n  getNodesInShortestPathOrder,\r\n} from \"../algorithms/dijkstras.js\";\r\n\r\nexport default class PathfindingVisualizer2 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      startNodePressed: false,\r\n      finishNodePressed: false,\r\n      start: { col: 5, row: 10 },\r\n      finish: { col: 45, row: 10 },\r\n      prevNode: null,\r\n      visited: 0,\r\n      counted: 0,\r\n    };\r\n    this.visualizeDijkstra = this.visualizeDijkstra.bind(this);\r\n    this.animateDijkstra = this.animateDijkstra.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  getInitialGrid = () => {\r\n    const grid = [];\r\n    for (let row = 0; row < 20; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < 50; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start.row && col === this.state.start.col,\r\n      isFinish: row === this.state.finish.row && col === this.state.finish.col,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n    };\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    if (row === this.state.start.row && col === this.state.start.col) {\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        startNodePressed: true,\r\n      });\r\n    } else if (row === this.state.finish.row && col === this.state.finish.col) {\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        finishNodePressed: true,\r\n      });\r\n    } else {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  handleMouseUp(row, col) {\r\n    //Originally there was no row, col being passed\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse UP row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        start: { row: row, col: col },\r\n        startNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else if (this.state.finishNodePressed) {\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        finish: { row: row, col: col },\r\n        finishNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else {\r\n      this.setState({ mouseIsPressed: false });\r\n    }\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (\r\n      this.state.mouseIsPressed &&\r\n      !this.state.startNodePressed &&\r\n      !this.state.finishNodePressed\r\n    ) {\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (this.state.startNodePressed) {\r\n      console.log(`mouse ENTER row:${row}  col:${col}`);\r\n      this.setState({\r\n        start: { row: row, col: col },\r\n      });\r\n    }\r\n    if (this.state.finishNodePressed) {\r\n      this.setState({\r\n        finish: { row: row, col: col },\r\n      });\r\n    }\r\n  }\r\n\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isWall: !node.isWall,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  getNewGridWithNodeToggled(type, grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: type === \"start\" ? !node.isStart : node.isStart,\r\n      isFinish: type === \"finish\" ? !node.isFinish : node.isFinish,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n      this.setState({ visited: i + 1 });\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    if (nodesInShortestPathOrder.length > 1) {\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }, 10 * i);\r\n        this.setState({ counted: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start.row][this.state.start.col];\r\n    const finishNode = grid[this.state.finish.row][this.state.finish.col];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  generateRandomMaze() {\r\n    const rows = 20,\r\n      cols = 50;\r\n    let newGrid = [];\r\n    for (let i = 0; i < Math.floor(Math.random() * cols * rows); i++) {\r\n      const randomRow = Math.floor(Math.random() * rows);\r\n      const randomCol = Math.floor(Math.random() * cols);\r\n      if (\r\n        (randomRow !== this.state.start.row ||\r\n          randomCol !== this.state.start.col) &&\r\n        (randomRow !== this.state.finish.row ||\r\n          randomCol !== this.state.finish.col)\r\n      ) {\r\n        console.log(`randomRow: ${randomRow} randomCol: ${randomCol}`);\r\n        newGrid = this.getNewGridWithWallToggled(\r\n          this.state.grid,\r\n          randomRow,\r\n          randomCol\r\n        );\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  }\r\n\r\n  reset() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  render() {\r\n    const { grid, visited, counted } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <h1>Pathfinding Visualizer</h1>\r\n        <div id=\"counters\">\r\n          <h2>Nodes visited: {visited}</h2>\r\n          <h2>Nodes counted: {counted}</h2>\r\n        </div>\r\n        <div>\r\n          <button id=\"btn\" onClick={() => this.visualizeDijkstra()}>\r\n            Visualize Dijkstra's algorithm\r\n          </button>\r\n          <button id=\"btn\" onClick={() => this.generateRandomMaze()}>\r\n            Generate Random Walls\r\n          </button>\r\n          <button id=\"btn\" onClick={() => this.reset()}>\r\n            Reset\r\n          </button>\r\n        </div>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    //isVisited,\r\n                    isWall,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      //isVisited={isVisited} //Uncommenting this causes the whole animation to render at once for some reason\r\n                      isWall={isWall}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport PathfindingVisualizer2 from \"./PathfindingVisualizer/PathfindingVisualizer2\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer2></PathfindingVisualizer2>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}