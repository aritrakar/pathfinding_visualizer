{"version":3,"sources":["PathfindingVisualizer/Node/Node.jsx","util/common.js","algorithms/dijkstras.js","algorithms/astar.js","util/queue.js","util/stack.js","PathfindingVisualizer/PathfindingVisualizer3.jsx","algorithms/bfs.js","algorithms/dfs.js","App.js","index.js"],"names":["Node","props","state","this","row","col","isStart","isFinish","isVisited","isWall","onMouseUp","onMouseDown","onMouseEnter","extraClassName","id","className","React","Component","getUnvisitedNeighbours","node","grid","neighbours","push","length","filter","neighbour","updateUnvisitedNeighbours1","distance","previousNode","updateUnvisitedNeighbours2","dijkstra","startNode","finishNode","visitedNodesInOrder","unvisitedNodes","nodes","getAllNodes","sortNodesByDistance","closestNode","shift","Infinity","pop","sort","nodeA","nodeB","ManhattanDistance","currentNode","targetNode","Math","abs","sortNodesByFScore","fscore","Queue","items","element","Stack","item","PathfindingVisualizer3","getInitialGrid","navbarHeight","document","getElementById","clientHeight","numCols","floor","window","innerWidth","numRows","innerHeight","setState","console","log","currentRow","createNode","algorithm","mouseIsPressed","startNodePressed","finishNodePressed","start","finish","speedText","speedSeconds","prevNode","visited","counted","animateAlgorithm","bind","handleMouseDown","handleMouseUp","handleMouseEnter","setSpeed","setAlgorithm","gscore","hscore","newGrid","slice","newNode","type","getNewGridWithNodeToggled","getNewGridWithWallToggled","nodesInShortestPathOrder","singleAnimationDuration","i","setTimeout","animateShortestPath","closedList","openList","includes","astar","queue","enqueue","isEmpty","dequeue","bfs","stack","dfs","unshift","getNodesInShortestPathOrder","random","randomRow","randomCol","event","target","name","value","root","clientWidth","location","reload","onChange","onClick","visualize","generateRandomMaze","reset","map","rowIdx","key","nodeIdx","App","ReactDOM","render"],"mappings":"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","file":"static/js/main.a5b07c3d.chunk.js","sourcesContent":["import React from \"react\";\r\nimport \"./Node.css\";\r\n\r\n/** \r\n * @class Represents a node in the grid which can be the \r\n * starting node, the ending node or a wall.\r\n * @prop {Number} row The row of the Node\r\n * @prop {number} col The col of the Node\r\n * @prop {boolean} isStart Is the Node a starting node\r\n * @prop {boolean} isFinish Is the Node an ending node\r\n * @prop {boolean} isVisited Has the Node been visited\r\n * @prop {function} onMouseUp Function to execute when mouse is up (released)\r\n * @prop {function} onMouseDown Function to execute when mouse is down (clicked)\r\n * @prop {function} onMouseEnter Function to execute when mouse enters the Node\r\n */\r\nexport default class Node extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {};\r\n  }\r\n  render() {\r\n    const {\r\n      row,\r\n      col,\r\n      isStart,\r\n      isFinish,\r\n      isVisited,\r\n      isWall,\r\n      onMouseUp,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n    } = this.props;\r\n\r\n    // Add extra class name for start, finish, wall or visited node\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : isVisited\r\n      ? \"node-visited\"\r\n      : \"\";\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp(row, col)}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","/**\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @returns {Node[]} 1D rray containing all nodes in grid\r\n */\r\nexport function getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n/**\r\n * @param {Node} node Node whose neighbours are fetched\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @returns Returns the unvisited neighbours of Node node as an array\r\n */\r\nexport function getUnvisitedNeighbours(node, grid) {\r\n  const neighbours = [];\r\n  const { col, row } = node;\r\n  //Top\r\n  if (row > 0) {\r\n    neighbours.push(grid[row - 1][col]);\r\n  }\r\n  //Bottom\r\n  if (row < grid.length - 1) {\r\n    neighbours.push(grid[row + 1][col]);\r\n  }\r\n  //Left\r\n  if (col > 0) {\r\n    neighbours.push(grid[row][col - 1]);\r\n  }\r\n  //Right\r\n  if (col < grid[row].length - 1) {\r\n    neighbours.push(grid[row][col + 1]);\r\n  }\r\n  return neighbours.filter(\r\n    (neighbour) => !neighbour.isVisited && !neighbour.isWall\r\n  );\r\n}\r\n\r\n/**\r\n * @description Sets the visited state of the neighbours of Node node to true.\r\n * @param {Node} node Node whose neighbours have to be updated\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nexport function updateUnvisitedNeighbours1(node, grid) {\r\n  const neighbours = getUnvisitedNeighbours(node, grid);\r\n  for (const neighbour of neighbours) {\r\n    neighbour.distance = node.distance + 1;\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * @description Sets the visited state of the neighbours of Node node to true.\r\n * @param {Node} node Node whose neighbours have to be updated\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nexport function updateUnvisitedNeighbours2(node, neighbours) {\r\n  for (const neighbour of neighbours) {\r\n    neighbour.previousNode = node;\r\n  }\r\n}\r\n\r\n/**\r\n * @description Gets the Nodes in the shortest path from start to finish.\r\n * Backtracks from the finishNode to find the shortest path.\r\n * Only works when called *after* the dijkstra method above.\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes in the shortest path as an array\r\n */\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder;\r\n}\r\n","import { getAllNodes, updateUnvisitedNeighbours1 } from \"../util/common\";\r\n\r\n/**\r\n * @description Finds the shortest path between startNode and finishNode using Dijkstra's shortest path algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes that have been VISITED (NOT the shortest path)\r\n */\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  /*\r\n  if (!startNode || !finishNode || startNode === finishNode) {\r\n    //Exceptional case with no startNode, no finishNode, or when they're equal\r\n    return false;\r\n  } */\r\n\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n\r\n  // While there are still nodes to visit\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift(); //removes closestNode from unvisitedNodes\r\n\r\n    // If the closest node is a wall\r\n    if (closestNode.isWall) continue;\r\n\r\n    //When there are NO valid paths. Eg. walls around source or target\r\n    if (closestNode.distance === Infinity) {\r\n      visitedNodesInOrder.pop();\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n\r\n    // Found target\r\n    if (closestNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n    updateUnvisitedNeighbours1(closestNode, grid);\r\n  }\r\n}\r\n\r\n/**\r\n * @description Sorts Nodes by distance\r\n * @param {Node[]} unvisitedNodes Array of unvisited Nodes\r\n */\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance); //Absolute value?\r\n}\r\n","import {\r\n  getUnvisitedNeighbours,\r\n  updateUnvisitedNeighbours1,\r\n} from \"../util/common\";\r\n\r\n/**\r\n * @description Finds the shortest path between startNode and finishNode using the A* search algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes that have been VISITED (NOT the shortest path)\r\n */\r\nexport function astar(grid, startNode, finishNode) {\r\n  const closedList = [];\r\n  const openList = [startNode]; //getAllNodes(grid);\r\n  //openList.unshift(startNode);\r\n  startNode.gscore = 0;\r\n  startNode.fscore = ManhattanDistance(startNode, finishNode);\r\n\r\n  while (!!openList.length) {\r\n    sortNodesByFScore(openList);\r\n    const currentNode = openList.shift();\r\n    console.log(`currentNode: ${currentNode.col} ${currentNode.row}`);\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    if (currentNode === finishNode) {\r\n      console.log(\"closedList: \", closedList);\r\n      return closedList;\r\n    }\r\n\r\n    currentNode.isVisited = true;\r\n    closedList.push(currentNode);\r\n\r\n    const neighbours = getUnvisitedNeighbours(currentNode, grid);\r\n    for (const neighbour of neighbours) {\r\n      if (!closedList.includes(neighbour)) {\r\n        neighbour.gscore = currentNode.gscore + 1; //1 is the distance between currentNode and neighbour\r\n        neighbour.hscore = ManhattanDistance(neighbour, finishNode);\r\n        neighbour.fscore = neighbour.gscore + neighbour.hscore;\r\n\r\n        if (!openList.includes(neighbour)) {\r\n          openList.push(neighbour);\r\n        }\r\n      }\r\n    }\r\n\r\n    updateUnvisitedNeighbours1(currentNode, grid);\r\n  }\r\n}\r\n\r\n/**\r\n * @description Manhattan distance between (x1,y1) and (x2,y2) is calculated as |x1-x2| + |y1-y2|\r\n * @param {Node} currentNode\r\n * @param {Node} targetNode\r\n * @returns Manhattan distance between currentNode and targetNode\r\n */\r\nfunction ManhattanDistance(currentNode, targetNode) {\r\n  const temp =\r\n    Math.abs(currentNode.col - targetNode.col) +\r\n    Math.abs(currentNode.row - targetNode.row);\r\n  return temp;\r\n}\r\n\r\n/**\r\n * @description Sorts the entire grid by the f-score\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n */\r\nfunction sortNodesByFScore(grid) {\r\n  grid.sort((nodeA, nodeB) => nodeA.fscore - nodeB.fscore);\r\n}\r\n","export default class Queue {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  // add element to the queue\r\n  enqueue(element) {\r\n    return this.items.push(element);\r\n  }\r\n\r\n  // remove element from the queue\r\n  dequeue() {\r\n    if (this.items.length > 0) {\r\n      return this.items.shift();\r\n    }\r\n  }\r\n\r\n  // view the last element\r\n  peek() {\r\n    return this.items[this.items.length - 1];\r\n  }\r\n\r\n  // check if the queue is empty\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  // the size of the queue\r\n  size() {\r\n    return this.items.length;\r\n  }\r\n\r\n  // empty the queue\r\n  clear() {\r\n    this.items = [];\r\n  }\r\n}\r\n","export default class Stack {\r\n  constructor() {\r\n    this.items = [];\r\n  }\r\n\r\n  // Add element to the stack\r\n  push(element) {\r\n    return this.items.push(element);\r\n  }\r\n\r\n  // Remove element from the stack\r\n  pop() {\r\n    return this.items.pop();\r\n  }\r\n\r\n  isEmpty() {\r\n    return this.items.length === 0;\r\n  }\r\n\r\n  clear() {\r\n    this.item = [];\r\n  }\r\n}\r\n","import React from \"react\";\r\nimport Node from \"./Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\n//import { astar } from \"../algorithms/astar\";\r\n// import {\r\n//   dijkstra,\r\n//   getNodesInShortestPathOrder,\r\n// } from \"../algorithms/dijkstras.js\";\r\n//import {bfs} from \"../algorithms/bfs\";\r\nimport { dijkstra, astar, bfs, dfs } from \"../algorithms\";\r\nimport { getNodesInShortestPathOrder } from \"../util/common\";\r\n\r\nexport default class PathfindingVisualizer3 extends React.Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      numRows: 0,\r\n      numCols: 0,\r\n      algorithm: \"Dijkstra's\",\r\n      mouseIsPressed: false,\r\n      startNodePressed: false,\r\n      finishNodePressed: false,\r\n      start: { col: 5, row: 10 },\r\n      finish: { col: 20, row: 10 },\r\n      speedText: \"Fast\",\r\n      speedSeconds: 10,\r\n      prevNode: null,\r\n      visited: 0,\r\n      counted: 0,\r\n    };\r\n    this.animateAlgorithm = this.animateAlgorithm.bind(this);\r\n    this.handleMouseDown = this.handleMouseDown.bind(this);\r\n    this.handleMouseUp = this.handleMouseUp.bind(this);\r\n    this.handleMouseEnter = this.handleMouseEnter.bind(this);\r\n    this.setSpeed = this.setSpeed.bind(this);\r\n    this.setAlgorithm = this.setAlgorithm.bind(this);\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = this.getInitialGrid();\r\n    this.setState({ grid: grid });\r\n  }\r\n\r\n  /**\r\n   * @description Creates a grid of Nodes\r\n   * @returns Grid (2D array) of Nodes\r\n   */\r\n  getInitialGrid = () => {\r\n    var navbarHeight = document.getElementById(\"navbar\").clientHeight;\r\n    const grid = [];\r\n    const numCols = Math.floor((window.innerWidth - 160) / 40);\r\n    const numRows = Math.floor((window.innerHeight - navbarHeight - 120) / 40);\r\n    this.setState({numRows, numCols})\r\n    console.log(`numCols: ${numCols} numRows: ${numRows}`);\r\n    for (let row = 0; row < numRows; row++) {\r\n      const currentRow = [];\r\n      for (let col = 0; col < numCols; col++) {\r\n        currentRow.push(this.createNode(col, row));\r\n      }\r\n      grid.push(currentRow);\r\n    }\r\n    return grid;\r\n  };\r\n\r\n  /**\r\n   * @description Creates a single unvisited Node that is not a wall\r\n   * @param {number} col The column of the Node to be created\r\n   * @param {number} row The row of the Node to be created\r\n   * @returns \r\n   */\r\n  createNode(col, row) {\r\n    return {\r\n      col,\r\n      row,\r\n      isStart: row === this.state.start.row && col === this.state.start.col,\r\n      isFinish: row === this.state.finish.row && col === this.state.finish.col,\r\n      distance: Infinity,\r\n      isVisited: false,\r\n      isWall: false,\r\n      previousNode: null,\r\n      gscore: 0,\r\n      hscore: 0,\r\n      fscore: 0,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @description Toggles the wall state of Node at (row, col) \r\n   * @param {Node[][]} grid Grid (2D array) of Nodes\r\n   * @param {number} row Row of the Node to toggle to wall\r\n   * @param {number} col Column of the Node to toggle to wall\r\n   * @returns Grid with wall toggled at (row, col)\r\n   */\r\n  getNewGridWithWallToggled(grid, row, col) {\r\n    // (Shallow) Copy the entire grid\r\n    const newGrid = grid.slice();\r\n\r\n    // Get the reference to the Node to change to wall\r\n    const node = newGrid[row][col];\r\n\r\n    // Make new Node with toggled wall\r\n    const newNode = {\r\n      ...node, // Get other details using the spread operator\r\n      isWall: !node.isWall,\r\n    };\r\n\r\n    // Set newNode in the new grid\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  /**\r\n   * @description Toggles Node at (row, col) to a start/finish Node\r\n   * @param {string} type Type of Node to toggle to, ie. start or finish Node\r\n   * @param {Node[][]} grid Grid (2D array) of Nodes\r\n   * @param {number} row Row of the Node to toggle start/finish node\r\n   * @param {number} col Column of the Node to toggle to start/finish node\r\n   * @returns Grid with Node toggled at (row, col) to start/finish Node\r\n   */\r\n  getNewGridWithNodeToggled(type, grid, row, col) {\r\n    const newGrid = grid.slice();\r\n    const node = newGrid[row][col];\r\n    const newNode = {\r\n      ...node,\r\n      isStart: type === \"start\" ? !node.isStart : node.isStart,\r\n      isFinish: type === \"finish\" ? !node.isFinish : node.isFinish,\r\n    };\r\n    newGrid[row][col] = newNode;\r\n    return newGrid;\r\n  }\r\n\r\n  /**\r\n   * @description Handles the necessary state changes when a Node is clicked but not released\r\n   * @param {number} row Row of the Node which has been clicked \r\n   * @param {number} col Column of the Node which has been clicked \r\n   */\r\n  handleMouseDown(row, col) {\r\n    if (row === this.state.start.row && col === this.state.start.col) { // Start Node is pressed\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      // Toggle start Node to unvisited Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        startNodePressed: true,\r\n      });\r\n    } else if (row === this.state.finish.row && col === this.state.finish.col) { // Finish Node is pressed\r\n      console.log(`mouse DOWN row:${row}  col:${col}`);\r\n\r\n      // Toggle finish Node to unvisited Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        mouseIsPressed: true,\r\n        finishNodePressed: true,\r\n      });\r\n    } else { //Unvisited Node is pressed\r\n      // Toggle unvisited Node to wall Node\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid, mouseIsPressed: true });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Handles the necessary state changes when a Node is released\r\n   * @param {number} row Row of the Node which has been released \r\n   * @param {number} col Column of the Node which has been released \r\n   */\r\n  handleMouseUp(row, col) {\r\n    //Originally there was no row, col being passed\r\n    if (this.state.startNodePressed) { //Start Node\r\n      console.log(`mouse UP row:${row}  col:${col}`);\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"start\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        start: { row: row, col: col },\r\n        startNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else if (this.state.finishNodePressed) { // Finish Node\r\n      const newGrid = this.getNewGridWithNodeToggled(\r\n        \"finish\",\r\n        this.state.grid,\r\n        row,\r\n        col\r\n      );\r\n      this.setState({\r\n        grid: newGrid,\r\n        finish: { row: row, col: col },\r\n        finishNodePressed: false,\r\n        mouseIsPressed: false,\r\n      });\r\n    } else { // Unvisited Node\r\n      this.setState({ mouseIsPressed: false });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Toggles Node at (row, col) to start, finish or wall Node\r\n   * @param {number} row Row of the Node that the mouse enters \r\n   * @param {number} col Column of the Node that the mouse enters\r\n   */\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    if (\r\n      this.state.mouseIsPressed &&\r\n      !this.state.startNodePressed &&\r\n      !this.state.finishNodePressed\r\n    ) {\r\n      // Toggle unvisited Node to a Wall Node\r\n      const newGrid = this.getNewGridWithWallToggled(this.state.grid, row, col);\r\n      this.setState({ grid: newGrid });\r\n    }\r\n    if (this.state.startNodePressed) { // Toggle Node at (row, col) to start Node\r\n      console.log(`mouse ENTER row:${row}  col:${col}`);\r\n      this.setState({\r\n        start: { row: row, col: col },\r\n      });\r\n    }\r\n    if (this.state.finishNodePressed) { // Toggle Node at (row, col) to finish Node\r\n      this.setState({\r\n        finish: { row: row, col: col },\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Animate the Nodes in the grid according to order \r\n   * in which they have been visited by the algorithm\r\n   * @param {Node[]} visitedNodesInOrder Array of Nodes visited in order\r\n   * @param {Node[]} nodesInShortestPathOrder  Array of Nodes in the shortest path\r\n   */\r\n  animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n\r\n    if (visitedNodesInOrder?.length > 0){\r\n      // Traverse the visitedNodesInOrder array and set each Node to visited\r\n      for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n        // If it is the last Node then animate the shortest path\r\n        if (i === visitedNodesInOrder.length) {\r\n          setTimeout(() => {\r\n            this.animateShortestPath(nodesInShortestPathOrder);\r\n          }, singleAnimationDuration * i);\r\n          return;\r\n        }\r\n\r\n        // Set Node to visited and change its HTML class\r\n        setTimeout(() => {\r\n          const node = visitedNodesInOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-visited\";\r\n        }, singleAnimationDuration * i);\r\n\r\n        // Increase the visited Nodes count\r\n        this.setState({ visited: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Animates the Nodes in the shortest path from start to end Node\r\n   * @param {Node[]} nodesInShortestPathOrder Array of Nodes in the shortest path\r\n   */\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    const singleAnimationDuration = this.state.speedSeconds;\r\n\r\n    // Shortest path length must be greater than 1 for an animation to happen\r\n    // There's nothing to animate if the start and end Nodes are adjacent\r\n    if (nodesInShortestPathOrder.length > 1) {\r\n      // Traverse through the array and set each Node to the 'node-shortest-path' HTML class\r\n      for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n        setTimeout(() => {\r\n          const node = nodesInShortestPathOrder[i];\r\n          document.getElementById(`node-${node.row}-${node.col}`).className =\r\n            \"node node-shortest-path\";\r\n        }, singleAnimationDuration * i);\r\n\r\n        // Increase the counted Nodes count\r\n        this.setState({ counted: i + 1 });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Visualizes the chosen algorithm\r\n   */\r\n  visualize() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[this.state.start.row][this.state.start.col];\r\n    const finishNode = grid[this.state.finish.row][this.state.finish.col];\r\n    // const visitedNodesInOrder =\r\n    //   this.state.algorithm === \"Dijkstra's\"\r\n    //     ? dijkstra(grid, startNode, finishNode)\r\n    //     : astar(grid, startNode, finishNode);\r\n\r\n    let visitedNodesInOrder = [];\r\n    switch (this.state.algorithm) {\r\n      case \"Dijkstra's\":\r\n        visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n        break;\r\n      case \"A*\":\r\n        visitedNodesInOrder = astar(grid, startNode, finishNode);\r\n        break;\r\n      case \"BFS\":\r\n        visitedNodesInOrder = bfs(grid, startNode, finishNode);\r\n        break;\r\n      case \"DFS\":\r\n          visitedNodesInOrder = dfs(grid, startNode, finishNode);\r\n          break;\r\n      default:\r\n        break;\r\n    }\r\n\r\n    // Get the nodes in the shortest path\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n\r\n    // Animate the algorithm\r\n    this.animateAlgorithm(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  /**\r\n   * @description Generates wall Nodes randomly\r\n   */\r\n  generateRandomMaze() {\r\n    //const rows = 20, cols = 50;\r\n    const {numRows, numCols} = this.state;\r\n    let newGrid = [];\r\n    for (let i = 0; i < Math.floor(Math.random() * numCols * numRows); i++) {\r\n      const randomRow = Math.floor(Math.random() * numRows);\r\n      const randomCol = Math.floor(Math.random() * numCols);\r\n      if (\r\n        (randomRow !== this.state.start.row ||\r\n          randomCol !== this.state.start.col) &&\r\n        (randomRow !== this.state.finish.row ||\r\n          randomCol !== this.state.finish.col)\r\n      ) {\r\n        //console.log(`randomRow: ${randomRow} randomCol: ${randomCol}`);\r\n        newGrid = this.getNewGridWithWallToggled(\r\n          this.state.grid,\r\n          randomRow,\r\n          randomCol\r\n        );\r\n        this.setState({ grid: newGrid });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description Sets the chosen algorithm. By default it is \"Dijkstra's\"\r\n   * @param {*} event \r\n   */\r\n  setAlgorithm(event) {\r\n    const { name, value } = event.target;\r\n    this.setState({ [name]: value });\r\n  }\r\n\r\n  /**\r\n   * @description Sets the chosen speed. By default it is \"Fast\", ie. 10ms\r\n   * @param {*} event \r\n   */\r\n  setSpeed(event) {\r\n    const { name, value } = event.target;\r\n    value === \"Fast\"\r\n      ? this.setState({ [name]: value, speedSeconds: 10 })\r\n      : value === \"Average\"\r\n      ? this.setState({ [name]: value, speedSeconds: 50 })\r\n      : this.setState({ [name]: value, speedSeconds: 100 });\r\n  }\r\n\r\n  /**\r\n   * @description Shows the dimensions of the 'window' and of 'root'\r\n   */\r\n  showWidth() {\r\n    console.log(\r\n      `window.width: ${window.innerWidth} window.innerHeight: ${window.innerHeight}`\r\n    );\r\n    var root = document.getElementById(\"root\");\r\n    console.log(\r\n      `root.clientWidth: ${root.clientWidth} root.clientHeight: ${root.clientHeight}`\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @description Resets the grid WITHOUT reloading the page\r\n   * Problem: Do not use this because it does not truly reset the graph and causes weird problems.\r\n   */\r\n  reset2(){\r\n    const {grid, numRows, numCols} = this.state;\r\n    for (let row = 0; row < numRows; row++) {\r\n      for (let col = 0; col < numCols; col++) {\r\n        if (grid[row][col].isStart) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node node-start\";\r\n        } else if (grid[row][col].isFinish) {\r\n          document.getElementById(`node-${row}-${col}`).className = \"node node-finish\";\r\n        } else {\r\n          if(grid[row][col].isWall) grid[row][col].isWall = false\r\n          document.getElementById(`node-${row}-${col}`).className = \"node\";\r\n        }\r\n      }\r\n    }\r\n    this.setState({grid, visited: 0, counted: 0})\r\n  }\r\n\r\n  /**\r\n   * @description Resets the grid by reloading the page\r\n   */\r\n  reset() {\r\n    //Hacky\r\n    window.location.reload(false);\r\n  }\r\n\r\n  render() {\r\n    const { grid, visited, counted } = this.state;\r\n\r\n    return (\r\n      <div>\r\n        <div id=\"navbar\">\r\n          <h1>Pathfinding Visualizer</h1>\r\n          <div id=\"counters\">\r\n            <h2>Nodes visited: {visited}</h2>\r\n            <h2>Nodes counted: {counted}</h2>\r\n          </div>\r\n          <div>\r\n            <select\r\n              id=\"algo_dropdown\"\r\n              name=\"algorithm\"\r\n              value={this.state.algorithm}\r\n              onChange={this.setAlgorithm}\r\n            >\r\n              <option value=\"Dijkstra's\">Diijkstra's</option>\r\n              <option value=\"A*\">A*</option>\r\n              <option value=\"BFS\">BFS</option>\r\n              <option value=\"DFS\">DFS</option>\r\n            </select>\r\n            <button id=\"btn\" onClick={() => this.visualize()}>\r\n              Visualize {this.state.algorithm}\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.generateRandomMaze()}>\r\n              Generate Random Walls\r\n            </button>\r\n            <button id=\"btn\" onClick={() => this.reset()}>\r\n              Reset\r\n            </button>\r\n            <select\r\n              id=\"speed_dropdown\"\r\n              name=\"speedText\"\r\n              value={this.state.speedText}\r\n              onChange={this.setSpeed}\r\n            >\r\n              <option value=\"Fast\">Fast</option>\r\n              <option value=\"Average\">Average</option>\r\n              <option value=\"Slow\">Slow</option>\r\n            </select>\r\n          </div>\r\n        </div>\r\n\r\n        <div className=\"grid\">\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const {\r\n                    row,\r\n                    col,\r\n                    isStart,\r\n                    isFinish,\r\n                    //isVisited,\r\n                    isWall,\r\n                  } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      row={row}\r\n                      col={col}\r\n                      isStart={isStart}\r\n                      isFinish={isFinish}\r\n                      //isVisited={isVisited} //Uncommenting this causes the whole animation to render at once for some reason\r\n                      isWall={isWall}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={(row, col) => this.handleMouseUp(row, col)}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n","import Queue from \"../util/queue\";\r\nimport {\r\n  getUnvisitedNeighbours,\r\n  updateUnvisitedNeighbours2,\r\n} from \"../util/common\";\r\n\r\n/**\r\n * @description Finds the shortest path between startNode and finishNode using the Breadth-First Search algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes that have been VISITED (NOT the shortest path)\r\n */\r\nexport function bfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const queue = new Queue();\r\n  startNode.isVisited = true;\r\n  queue.enqueue(startNode);\r\n\r\n  while (!queue.isEmpty()) {\r\n    const currentNode = queue.dequeue();\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const neighbours = getUnvisitedNeighbours(currentNode, grid);\r\n    for (const neighbour of neighbours) {\r\n      neighbour.isVisited = true;\r\n      queue.enqueue(neighbour);\r\n      visitedNodesInOrder.push(neighbour);\r\n    }\r\n    updateUnvisitedNeighbours2(currentNode, neighbours);\r\n  }\r\n}\r\n","import Stack from \"../util/stack\";\r\nimport {\r\n  getUnvisitedNeighbours,\r\n  updateUnvisitedNeighbours2,\r\n} from \"../util/common\";\r\n\r\n/**\r\n * @description Finds the shortest path between startNode and finishNode using the Depth-First Search algorithm\r\n * @param {Node[][]} grid Grid (2D array) of Nodes\r\n * @param {Node} startNode Start Node\r\n * @param {Node} finishNode Target Node\r\n * @returns {Node[]} Nodes that have been VISITED (NOT the shortest path)\r\n */\r\nexport function dfs(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  const stack = new Stack();\r\n  stack.push(startNode);\r\n\r\n  while (!stack.isEmpty()) {\r\n    const currentNode = stack.pop();\r\n\r\n    if (currentNode.isWall) continue;\r\n\r\n    if (currentNode === finishNode) {\r\n      return visitedNodesInOrder;\r\n    }\r\n\r\n    const neighbours = getUnvisitedNeighbours(currentNode, grid);\r\n    if (!currentNode.isVisited) {\r\n      currentNode.isVisited = true;\r\n\r\n      for (const neighbour of neighbours) {\r\n        stack.push(neighbour);\r\n        visitedNodesInOrder.push(neighbour);\r\n      }\r\n    }\r\n    updateUnvisitedNeighbours2(currentNode, neighbours);\r\n  }\r\n}\r\n","import React from \"react\";\nimport \"./App.css\";\n//import PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\n//import PathfindingVisualizer2 from \"./PathfindingVisualizer/PathfindingVisualizer2\";\nimport PathfindingVisualizer3 from \"./PathfindingVisualizer/PathfindingVisualizer3\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer3></PathfindingVisualizer3>\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <App />,\n  document.getElementById('root')\n);"],"sourceRoot":""}